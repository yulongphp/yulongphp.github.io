<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mryy的博客</title>
  
  <subtitle>生活不仅只是敲代码，还有...调bug...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yulongphp.github.io/"/>
  <updated>2018-08-22T09:43:49.625Z</updated>
  <id>http://yulongphp.github.io/</id>
  
  <author>
    <name>yulong yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql查询优化</title>
    <link href="http://yulongphp.github.io/2017/05/05/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://yulongphp.github.io/2017/05/05/mysql查询优化/</id>
    <published>2017-05-05T03:14:28.000Z</published>
    <updated>2018-08-22T09:43:49.625Z</updated>
    
    <content type="html"><![CDATA[<p>1、应尽量避免在  WHERE  子句中使用 != 或者 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>2、应尽量避免在  WHERE  子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num  IS  NULL;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>可以在 num 上设置默认值 0 ，确保表中 num 列没有 NULL 值，然后这样查询：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>3、对查询进行优化，应尽量避免全表扫描，首先应考虑在  WHERE  及 ORDER BY 涉及的列上建立索引。</p><p>4、尽量避免在  WHERE  子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num = <span class="number">10</span> OR num = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p><p>可以这样查询：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num = <span class="number">10</span> UNION ALL SELECT  id  FROM  t  WHERE  num = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p><p>5、下面的查询也将导致全表扫描：（不能前置百分号）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  name like <span class="string">'%abc%'</span>;</span><br></pre></td></tr></table></figure></p><p>若要提高效率，可以考虑全文检索。</p><p>6、 IN 和 NOT IN 也要慎用，否则会导致全表扫描，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num IN (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>对于连续的数值，能用 between 就不要用 IN 了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num BETWEEN <span class="number">1</span> AND <span class="number">3</span>;</span><br><span class="line">SELECT  xx,phone  FROM  send  a JOIN (</span><br><span class="line"> SELECT  <span class="string">'13891030091'</span> phone  UNION SELECT  <span class="string">'13992085916'</span> …………  UNION  SELECT  <span class="string">'13619100234'</span> ) b</span><br><span class="line">  on  a.Phone=b.phone</span><br></pre></td></tr></table></figure></p><p>–替代下面  很多数据隔开的时候<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN (<span class="string">'13891030091'</span>,<span class="string">'13992085916'</span>,<span class="string">'13619100234'</span>…………)</span><br></pre></td></tr></table></figure></p><p>7、如果在  WHERE  子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择到运行时；它必须在编译时进行选择。然而，如果在编译时简历访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num = @num;</span><br></pre></td></tr></table></figure></p><p>可以改为强制查询使用索引：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t <span class="keyword">with</span>(index(索引名))  WHERE  num = @num;</span><br></pre></td></tr></table></figure></p><p>8、应尽量避免在  WHERE  子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num/<span class="number">2</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>应改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  num = <span class="number">100</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>9、应尽量避免在  WHERE  子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  substring(name, <span class="number">1</span>, <span class="number">3</span>) = ’abc’–name;  //以abc开头的id</span><br><span class="line">SELECT  id  FROM  t  WHERE  datediff(day,createdate,’<span class="number">2005</span><span class="number">-11</span><span class="number">-30</span>′) = <span class="number">0</span>–’<span class="number">2005</span><span class="number">-11</span><span class="number">-30</span>′;  //生成的id</span><br></pre></td></tr></table></figure></p><p>应改为:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  id  FROM  t  WHERE  name like ‘abc%’</span><br><span class="line">SELECT  id  FROM  t  WHERE  createdate &gt;= ’<span class="number">2005</span><span class="number">-11</span><span class="number">-30</span>′ <span class="keyword">and</span> createdate &lt; ’<span class="number">2005</span><span class="number">-12</span><span class="number">-1</span>′;</span><br></pre></td></tr></table></figure></p><p>10、不要在  WHERE  子句中的 “=” 左边进行函数，算术运算或者其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12、不要些一些没有意义的查询，如需要生成一个空表结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  col1,col2 into <span class="comment">#t  FROM  t  WHERE  1=0;</span></span><br></pre></td></tr></table></figure></p><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="comment">#t(…)</span></span><br></pre></td></tr></table></figure></p><p>13、很多时候用 exists 代替 IN 是一个好的选择：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  num  FROM  a  WHERE  num IN (SELECT  num  FROM  b);</span><br></pre></td></tr></table></figure></p><p>用下面的语句替换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  num  FROM  a  WHERE  exists(SELECT  <span class="number">1</span>  FROM  b  WHERE  num=a.num);</span><br></pre></td></tr></table></figure></p><p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15、索引并不是越多越好，索引固然可以提高相应的 SELECT  的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>16、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为clustered 索引。</p><p>17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19、任何地方都不要使用 SELECT  *  FROM  t ，用具体的字段列表代替 *，不要返回用不到的任何字段。</p><p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 SELECT  into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。</p><p>24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><p>28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>30、尽量避免大事务操作，提高系统并发能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、应尽量避免在  WHERE  子句中使用 != 或者 &amp;lt;&amp;gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;2、应尽量避免在  WHERE  子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：&lt;br&gt;    &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT  id  FROM  t  WHERE  num  IS  NULL;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yulongphp.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yulongphp.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能监控那些令人激赏的命令行工具</title>
    <link href="http://yulongphp.github.io/2016/03/30/linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yulongphp.github.io/2016/03/30/linux性能监控常用命令/</id>
    <published>2016-03-30T07:30:00.000Z</published>
    <updated>2018-08-22T09:43:49.632Z</updated>
    
    <content type="html"><![CDATA[<p>转载出处：<a href="http://www.oschina.net/translate/command-line-tools-to-monitor-linux-performance" target="_blank" rel="noopener">http://www.oschina.net/translate/command-line-tools-to-monitor-linux-performance</a><br>英文原文：<a href="http://www.tecmint.com/command-line-tools-to-monitor-linux-performance/" target="_blank" rel="noopener">18 Command Line Tools to Monitor Linux Performance</a></p><p>对于系统和网络管理员来说每天监控和调试Linux系统的性能问题是一项繁重的工作。在IT领域作为一名Linux系统的管理员工作5年后，我逐渐认识到监控和保持系统启动并运行是多么的不容易。基于此原因，我们已编写了最常使用的18个命令行工具列表，这些工具将有助于每个Linux/Unix 系统管理员的工作。这些命令行工具可以在各种Linux系统下使用，可以用于监控和查找产生性能问题的原因。这个命令行工具列表提供了足够的工具，您可以挑选适用于您的监控场景的工具。<br><a id="more"></a></p><h3 id="1-Top-Linux进程监控"><a href="#1-Top-Linux进程监控" class="headerlink" title="1.Top-Linux进程监控"></a>1.Top-Linux进程监控</h3><p>Linux下的Top命令是一个性能监控程序，许多系统管理员常常用它来监控Linux性能，在许多<strong>Linux或者类Unix</strong>操作系统里都有这个命令。Top命令用于按一定的顺序显示所有正在运行而且处于活动状态的实时进程，而且会定期更新显示结果。这条命令显示了<strong>CPU的使用率、内存使用率、交换内存使用大小、高速缓存使用大小、缓冲区使用大小，进程PID、所使用命令</strong>以及其他。它还可以显示正在运行进程的内存和CPU占用多的情况。对系统管理员来说，top命令式是一个非常有用的，它可用于监控系统并在需要的时候采取正确的处理动作。让我们看看实际中的top命令。</p><pre><code># top </code></pre><p><a href="http://www.tecmint.com/command-line-tools-to-monitor-linux-performance/Top%20Command%20Example" target="_blank" rel="noopener"><img src="/images/topCommandExample.jpg" alt="Top Command Example" title="Top Command Example"></a> Top命令举例<br> <strong>有关Top命令更多的例子，请阅读</strong> <a href="http://www.tecmint.com/12-top-command-examples-in-linux/" target="_blank" rel="noopener">:Linux下12个使用Top命令的例子</a>。</p><h3 id="2-VmStat-–-虚拟内存统计"><a href="#2-VmStat-–-虚拟内存统计" class="headerlink" title="2. VmStat – 虚拟内存统计"></a>2. VmStat – 虚拟内存统计</h3><p>Linux 的&nbsp;<strong>VmStat</strong>&nbsp;命令用于显示<strong>虚拟内存</strong>、<strong>内核线程</strong>、<strong>磁盘</strong>、<strong>系统进程</strong>、<strong>I/O 块</strong>、<strong>中断</strong>、<strong>CPU 活动</strong> 等的统计信息。缺省情况下， vmstat 命令在 Linux 系统下不可用，你需要安装一个包含了 vmstat 程序的&nbsp;<strong>sysstat</strong>&nbsp;软件包。命令格式的常见用法是：</p><pre><code># vmstatprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st 1  0      0 810420  97380  70628    0    0   115     4   89   79  1  6 90  3  0</code></pre><p><strong>更多的 vmstat 例子，请阅读 :</strong> <a href="http://www.tecmint.com/linux-performance-monitoring-with-vmstat-and-iostat-commands/" target="_blank" rel="noopener">6 Linux 下的 Vmstat 命令实例</a> </p><h3 id="3-Lsof-列出打开的文件"><a href="#3-Lsof-列出打开的文件" class="headerlink" title="3.Lsof-列出打开的文件"></a>3.Lsof-列出打开的文件</h3><p>在许多Linux或者类Unix系统里都有lsof命令，它常用于以列表的形式显示所有打开的文件和进程。打开的文件包括<strong>磁盘文件、网络套接字、管道、设备和进程</strong>。使用这条命令的主要情形之一就是在无法挂载磁盘和显示正在使用或者打开某个文件的错误信息的时候。使用这条命令，你可以很容易地看到正在使用哪个文件。这条命令最常用的格式如下：</p><pre>#&nbsp;lsofCOMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;USER&nbsp;&nbsp;&nbsp;FD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NODE&nbsp;NAMEinit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;cwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;/init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;rtd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;/init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;&nbsp;&nbsp;38652&nbsp;&nbsp;&nbsp;17710339&nbsp;/sbin/initinit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;&nbsp;129900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;196453&nbsp;/lib/ld-2.5.soinit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;1693812&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;196454&nbsp;/lib/libc-2.5.soinit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;&nbsp;&nbsp;20668&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;196479&nbsp;/lib/libdl-2.5.soinit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;&nbsp;245376&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;196419&nbsp;/lib/libsepol.so.1init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;104,2&nbsp;&nbsp;&nbsp;&nbsp;93508&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;196431&nbsp;/lib/libselinux.so.1init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;&nbsp;10u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;953&nbsp;/dev/initctl</pre> <p><strong>有关lsof命令的用法和例子的更多信息，请参考</strong>： <a href="http://www.tecmint.com/10-lsof-command-examples-in-linux/" target="_blank" rel="noopener">Linux下10个使用lsof命令的例子</a>。</p><h3 id="4-Tcpdump-网络包分析器"><a href="#4-Tcpdump-网络包分析器" class="headerlink" title="4.Tcpdump-网络包分析器"></a>4.Tcpdump-网络包分析器</h3><p><strong>Tcpdump</strong>是最广泛使用的<strong>网络包分析器或者包监控程序</strong>之一，它用于捕捉或者过滤网络上指定接口上接收或者传输的<strong>TCP/IP</strong>包。它还有一个选项用于把捕捉到的包保存到文件里，以便以后进行分析。在几乎所有主要的Linux发布里，tcpdump都可以使用。</p><pre>#&nbsp;tcpdump&nbsp;-i&nbsp;eth0tcpdump:&nbsp;verbose&nbsp;output&nbsp;suppressed,&nbsp;use&nbsp;-v&nbsp;or&nbsp;-vv&nbsp;for&nbsp;full&nbsp;protocol&nbsp;decodelistening&nbsp;on&nbsp;eth0,&nbsp;link-type&nbsp;EN10MB&nbsp;(Ethernet),&nbsp;capture&nbsp;size&nbsp;96&nbsp;bytes22:08:59.617628&nbsp;IP&nbsp;tecmint.com.ssh&nbsp;&gt;&nbsp;115.113.134.3.static-mumbai.vsnl.net.in.28472:&nbsp;P&nbsp;2532133365:2532133481(116)&nbsp;ack&nbsp;3561562349&nbsp;win&nbsp;964822:09:07.653466&nbsp;IP&nbsp;tecmint.com.ssh&nbsp;&gt;&nbsp;115.113.134.3.static-mumbai.vsnl.net.in.28472:&nbsp;P&nbsp;116:232(116)&nbsp;ack&nbsp;1&nbsp;win&nbsp;964822:08:59.617916&nbsp;IP&nbsp;115.113.134.3.static-mumbai.vsnl.net.in.28472&nbsp;&gt;&nbsp;tecmint.com.ssh:&nbsp;.&nbsp;ack&nbsp;116&nbsp;win&nbsp;64347</pre> <p><strong>要想获得更多有关tcpdump用法的信息，请参阅</strong>： <a href="http://www.tecmint.com/12-tcpdump-commands-a-network-sniffer-tool/" target="_blank" rel="noopener">Linux下12个使用Tcpdump命令的例子。</a> </p><h3 id="5-Netstat-网络状态统计"><a href="#5-Netstat-网络状态统计" class="headerlink" title="5.Netstat-网络状态统计"></a>5.Netstat-网络状态统计</h3><p>Netstat是一个用于监控<strong>进出网络</strong>的包和网络接口统计的命令行工具。它是一个非常有用的工具，系统管理员可以用来监控网络性能，定位并解决网络相关问题。</p><pre>#&nbsp;netstat&nbsp;-a&nbsp;|&nbsp;moreActive&nbsp;Internet&nbsp;connections&nbsp;(servers&nbsp;and&nbsp;established)Proto&nbsp;Recv-Q&nbsp;Send-Q&nbsp;Local&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foreign&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Statetcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;*:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;*:sunrpc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;*:realm-rusd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;*:ftp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;localhost.localdomain:ipp&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;localhost.localdomain:smtp&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;localhost.localdomain:smtp&nbsp;&nbsp;localhost.localdomain:42709&nbsp;TIME_WAITtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;localhost.localdomain:smtp&nbsp;&nbsp;localhost.localdomain:42710&nbsp;TIME_WAITtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;*:http&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;*:ssh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENtcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;*:https&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTEN</pre> <p><strong>有关Netstat更多的例子，请参阅</strong>: <a href="http://www.tecmint.com/20-netstat-commands-for-linux-network-management/" target="_blank" rel="noopener">Linux下20个使用Netstat命令的例子。</a> </p><h3 id="6-Htop-–-Linux进程监控"><a href="#6-Htop-–-Linux进程监控" class="headerlink" title="6. Htop – Linux进程监控"></a>6. Htop – Linux进程监控</h3><p><strong>Htop</strong>&nbsp;是一个非常高级的交互式的实时linux进程监控工具。 它和top命令十分相似，但是它具有更丰富的特性，例如用户可以友好地管理进程，快捷键，垂直和水平方式显示进程等等。 Htop是一个第三方工具，它不包含在linux系统中，你需要使用YUM包管理工具去安装它。 关于安装的更多信息，请阅读下文.</p><pre>#&nbsp;htop</pre> <p><img src="/images/htopCommandExample.jpg" alt="Htop Command Example" title="Htop Command Example"> </p><p>Htop 命令示例截图</p><p><strong>对于Htop的安装，请读&nbsp;: <a href="http://www.tecmint.com/install-htop-linux-process-monitoring-for-rhel-centos-fedora/" target="_blank" rel="noopener">在Linux安装Htop(Linux进程监控)</a></strong> </p><h3 id="7-Iotop-监控Linux磁盘I-O"><a href="#7-Iotop-监控Linux磁盘I-O" class="headerlink" title="7.Iotop-监控Linux磁盘I/O"></a><strong>7.Iotop-监控Linux磁盘I/O</strong></h3><p><strong>Iotop</strong>命令同样也非常类似于<strong>top**</strong>命令<strong>和</strong>Htop程序<strong>，不过它具有监控并显示实时</strong>磁盘I/O和进程**的统计功能。在查找具体进程和大量使用磁盘读写进程的时候，这个工具就非常有用。</p><pre>#&nbsp;iotop</pre> <p><img src="/images/ioTopCommandExample.jpg" alt="Iotop Command Example" title="Iotop Command Example"> Iotop命令举例的截图<br> <strong>有关如何安装和使用iotop的信息，请阅读</strong>： <a href="http://www.tecmint.com/install-iotop-monitor-linux-disk-io-in-rhel-centos-and-fedora/" target="_blank" rel="noopener">在Linux下安装Iotop。</a> </p><h3 id="8-Iostat-输入-输出统计"><a href="#8-Iostat-输入-输出统计" class="headerlink" title="8.Iostat-输入/输出统计"></a>8.Iostat-输入/输出统计</h3><p><strong>Iostat</strong>是一个用于收集显示系统存储设备<strong>输入和输出</strong>状态统计的简单工具。这个工具常常用来追踪存储设备的性能问题，其中存储设备包括<strong>设备、本地磁盘，以及诸如使用NFS等的远端磁盘</strong>。</p><pre>#&nbsp;iostatLinux&nbsp;2.6.18-238.9.1.el5&nbsp;(tecmint.com)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;09/13/2012avg-cpu:&nbsp;&nbsp;%user&nbsp;&nbsp;&nbsp;%nice&nbsp;%system&nbsp;%iowait&nbsp;&nbsp;%steal&nbsp;&nbsp;&nbsp;%idle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.60&nbsp;&nbsp;&nbsp;&nbsp;3.65&nbsp;&nbsp;&nbsp;&nbsp;1.04&nbsp;&nbsp;&nbsp;&nbsp;4.29&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;88.42Device:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tps&nbsp;&nbsp;&nbsp;Blk_read/s&nbsp;&nbsp;&nbsp;Blk_wrtn/s&nbsp;&nbsp;&nbsp;Blk_read&nbsp;&nbsp;&nbsp;Blk_wrtncciss/c0d0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;545.80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;256.52&nbsp;&nbsp;855159769&nbsp;&nbsp;401914750cciss/c0d0p1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5459&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3518cciss/c0d0p2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;533.97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;245.18&nbsp;&nbsp;836631746&nbsp;&nbsp;384153384cciss/c0d0p3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.97&nbsp;&nbsp;&nbsp;&nbsp;8737650&nbsp;&nbsp;&nbsp;&nbsp;6215544cciss/c0d0p4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0cciss/c0d0p5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.03&nbsp;&nbsp;&nbsp;&nbsp;5936778&nbsp;&nbsp;&nbsp;&nbsp;7882528cciss/c0d0p6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.34&nbsp;&nbsp;&nbsp;&nbsp;3847771&nbsp;&nbsp;&nbsp;&nbsp;3659776</pre> <p><strong>有关iostat用法和举例的更多信息，请访问</strong>: <a href="http://www.tecmint.com/linux-performance-monitoring-with-vmstat-and-iostat-commands/" target="_blank" rel="noopener">Linux下6个使用iostat命令的例子</a>。</p><h3 id="9-IPTraf-实时局域网IP监控"><a href="#9-IPTraf-实时局域网IP监控" class="headerlink" title="9.IPTraf-实时局域网IP监控"></a>9.IPTraf-实时局域网IP监控</h3><p><strong>IPTraf</strong>是一个在<strong>Linux</strong>控制台运行的、开放源代码的实时网络（<strong>局域网</strong>）监控应用。它采集了大量信息，比如通过网络的IP流量监控，包括TCP标记、ICMP详细信息、TCP/UDP流量分离、TCP连接包和字节数。同时还采集有关接口状态的常见信息和详细信息：TCP、UDP、IP、ICMP、非IP，IP校验和错误，接口活动等。</p><p><img src="/images/iptraf.png" alt="IP Traffic Monitor"> </p><p>IP流量监控<br> <strong>有关IPTraf工具用法以及其他更多信息，请访问：</strong> <a href="http://www.tecmint.com/real-time-interactive-ip-lan-monitoring-with-iptraf-tool/" target="_blank" rel="noopener">IPTraf网络监控工具</a>。</p><h3 id="10-psacct-或者-acct-监视用户活动"><a href="#10-psacct-或者-acct-监视用户活动" class="headerlink" title="10. psacct 或者 acct - 监视用户活动"></a>10. psacct 或者 acct - 监视用户活动</h3><p>psacct或者acct工具用于监视系统里每个用户的活动状况。这两个服务进程运行在后台，它们对系统上运行的每个用户的所有活动进行近距离监视，同时还监视这些活动所使用的资源情况。</p><p>系统管理员可以使用这两个工具跟踪每个用户的活动，比如用户正在做什么，他们提交了那些命令，他们使用了多少资源，他们在系统上持续了多长时间等等。</p><p>有关这些命令的安装和用法举例信息，请参阅文章：<a href="http://www.tecmint.com/how-to-monitor-user-activity-with-psacct-or-acct-tools/" target="_blank" rel="noopener">使用psacct或者acct监视用户活动</a>。</p><h3 id="11-Monit-Linux进程和服务监控工具"><a href="#11-Monit-Linux进程和服务监控工具" class="headerlink" title="11.Monit - Linux进程和服务监控工具"></a>11.Monit - Linux进程和服务监控工具</h3><p>Monit是一个免费的开源软件，也是一个基于网络的进程监控工具。它能自动监控和管理系统进程，程序，文件，文件夹，权限，总和验证码和文件系统。</p><p>这个软件能监控像Apache, MySQL, Mail, FTP, ProFTP, Nginx, SSH这样的服务。你可以通过命令行或者这个软件提供的网络借口来查看系统状态。</p><p><img src="/images/moint.jpg" alt="The Interface of Moint"> </p><p>Monit Linux系统监控</p><p>更多内容请参阅：<a href="http://www.tecmint.com/how-to-install-and-setup-monit-linux-process-and-services-monitoring-program/" target="_blank" rel="noopener">用Monit监控Linux进程</a> </p><h3 id="12-NetHogs-监视每个进程使用的网络带宽"><a href="#12-NetHogs-监视每个进程使用的网络带宽" class="headerlink" title="12.NetHogs-监视每个进程使用的网络带宽"></a>12.NetHogs-监视每个进程使用的网络带宽</h3><p><strong>NetHogs</strong>是一个开放源源代码的很小程序（与Linux下的<strong>top命令</strong>很相似），它密切监视着系统上每个进程的网络活动。同时还追踪着每个程序或者应用所使用的实时网络带宽。</p><p><img src="/images/netHogs.jpg" alt="NetHogs Linux Bandwidth Monitoring"> </p><p>NetHogs：Linux下的带宽监视<br> <strong>更多信息请参阅：</strong> <a href="http://www.tecmint.com/nethogs-monitor-per-process-network-bandwidth-usage-in-real-time/" target="_blank" rel="noopener">使用NetHogs监视Linux的网络带宽使用状况。</a></p><h3 id="13-iftop-监视网络带宽"><a href="#13-iftop-监视网络带宽" class="headerlink" title="13.iftop-监视网络带宽"></a>13.iftop-监视网络带宽</h3><p><strong>iftop</strong>是另一个在控制台运行的开放源代码系统监控应用，它显示了系统上通过网络接口的应用网络带宽使用（源主机或者目的主机）的列表，这个列表定期更新。iftop用于监视网络的使用情况，而<strong>‘top’</strong>用于监视CPU的使用情况。iftop是<strong>‘top’</strong>工具系列中的一员，它用于监视所选接口，并显示两个主机间当前网络带宽的使用情况。</p><p><img src="/images/iftop.png" alt="iftop - Network Bandwidth Monitoring"> </p><p>iftop-监视网络带宽。</p><p><strong>更多信息请参阅：</strong><a href="http://www.tecmint.com/install-iftop-bandwidth-monitoring-tool-in-rhel-centos-fedora/" target="_blank" rel="noopener">iftop-监视网络带宽的使用情况</a>。</p><h3 id="14-Monitorix-系统和网络监控"><a href="#14-Monitorix-系统和网络监控" class="headerlink" title="14 Monitorix-系统和网络监控"></a>14 Monitorix-系统和网络监控</h3><p>Monitorix 是一个免费的轻量级应用工具，它的设计初衷是运行和监控Linux/Unix服务器系统和资源等。它有一个HTTP 网络服务器，这个服务器有规律的收集系统和网络的信息并以图形化的形式展示出来。它监控系统的平均负载和使用，内存分配、磁盘健康状况、系统服务、网络端口、邮件统计（Sendmail，Postfix,Dovecot等），MySQL统计，等等。它就是用来监控系统的总体性能，帮助发现失误、瓶颈和异常活动的。</p><p><img src="/images/Monitorix.png" alt=""> </p><h3 id="15-Arpwatch-–-以太网活动监视器"><a href="#15-Arpwatch-–-以太网活动监视器" class="headerlink" title="15. Arpwatch – 以太网活动监视器"></a>15. Arpwatch – 以太网活动监视器</h3><p><strong>Arpwatch</strong>被设计用来监控Linux上的以太网地址解析 (<strong>MAC</strong>和<strong>IP</strong>地址的变化)。他在一段时间内持续监控以太网活动并输出IP和MAC地址配对变动的日志。它还可以向管理员发送邮件通知，对地址配对的增改发出警告。这对于检测网络上的ARP攻击很有用。&nbsp;</p><p><strong>更多信息请参阅</strong> : <a href="http://www.tecmint.com/monitor-ethernet-activity-in-linux/" target="_blank" rel="noopener">Arpwatch to Monitor Ethernet Activity</a> </p><h3 id="16-Suricata-–-网络安全监控"><a href="#16-Suricata-–-网络安全监控" class="headerlink" title="16. Suricata – 网络安全监控"></a>16. Suricata – 网络安全监控</h3><p><strong>Suricata</strong>&nbsp;是一个开源的高性能网络安全、入侵检测和反监测工具，可以运行Linux、FreeBSD和Windows上。非营利组织<strong>OISF</strong> (<strong>Open Information Security Foundation</strong>)开发并拥有其版权。</p><p><strong>更多信息请参阅</strong> : <a href="http://www.tecmint.com/suricata-a-network-intrusion-detection-prevention-system/" target="_blank" rel="noopener">Suricata – A Network Intrusion Detection and Prevention System</a> </p><h3 id="17-VnStat-PHP-–-网络流量监控"><a href="#17-VnStat-PHP-–-网络流量监控" class="headerlink" title="17. VnStat PHP – 网络流量监控"></a>17. VnStat PHP – 网络流量监控</h3><p><strong>VnStat PHP</strong>&nbsp;是流行网络工具”vnstat”的基于web的前端呈现。<strong>VnStat PHP</strong>&nbsp;将网络使用情况呈现在漂亮的图形界面中。他可以显示以小时、日、月计的上传和下载流量并输出总结报告。</p><p><strong>更多信息请参阅</strong> : <a href="http://www.tecmint.com/vnstat-php-frontend-for-monitoring-network-bandwidth/" target="_blank" rel="noopener">VnStat PHP – Monitoring Network Bandwidth</a> </p><h3 id="18-Nagios-–-网络-服务器监控"><a href="#18-Nagios-–-网络-服务器监控" class="headerlink" title="18. Nagios – 网络/服务器监控"></a>18. Nagios – 网络/服务器监控</h3><p>Nagios是领先而强大的开源监控系统，他可以让网络/系统管理员在问题影响到正常的业务之前发现并解决它们。有了Nagios系统，管理员可以在单个窗口内远程检测Linux、Windows、开关、路由器和打印机。它可以危险警告并指出系统/服务器是否有异常，这可以间接帮助你在问题发生之前采取抢救措施。</p><p><strong>更多信息请参阅</strong> : <a href="http://www.tecmint.com/install-nagios-in-linux/" target="_blank" rel="noopener">Install Nagios Monitoring System to Monitor Remote Linux/Windows Hosts</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载出处：&lt;a href=&quot;http://www.oschina.net/translate/command-line-tools-to-monitor-linux-performance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.oschina.net/translate/command-line-tools-to-monitor-linux-performance&lt;/a&gt;&lt;br&gt;英文原文：&lt;a href=&quot;http://www.tecmint.com/command-line-tools-to-monitor-linux-performance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;18 Command Line Tools to Monitor Linux Performance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于系统和网络管理员来说每天监控和调试Linux系统的性能问题是一项繁重的工作。在IT领域作为一名Linux系统的管理员工作5年后，我逐渐认识到监控和保持系统启动并运行是多么的不容易。基于此原因，我们已编写了最常使用的18个命令行工具列表，这些工具将有助于每个Linux/Unix 系统管理员的工作。这些命令行工具可以在各种Linux系统下使用，可以用于监控和查找产生性能问题的原因。这个命令行工具列表提供了足够的工具，您可以挑选适用于您的监控场景的工具。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yulongphp.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yulongphp.github.io/tags/linux/"/>
    
      <category term="service" scheme="http://yulongphp.github.io/tags/service/"/>
    
      <category term="nginx" scheme="http://yulongphp.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>C语言的局部变量和全局变量</title>
    <link href="http://yulongphp.github.io/2015/06/02/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>http://yulongphp.github.io/2015/06/02/C语言的局部变量和全局变量/</id>
    <published>2015-06-02T09:22:13.000Z</published>
    <updated>2018-08-22T09:43:49.633Z</updated>
    
    <content type="html"><![CDATA[<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在一个函数内部定义的变量称为<strong>局部变量</strong>，它的作用域仅限于该函数内，也就是说只有本函数内才能使用它们，在此函数以外是不能使用这些变量的。</p><p>例如：<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b, c;          <span class="comment">/* a, b, c 有效 */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;          <span class="comment">/* x, y, i, j  有效*/</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n;          <span class="comment">/* m, n 有效*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几点说明：<br>    1) <code>main</code>函数中定义的变量也是局部变量，只能在<code>main</code>函数中使用；同时，<code>main</code>函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。<br>    2) 不同函数中可以使用相同名字的变量，它们代表不同的对象，在内存中站不同的单元，互不混淆。<br>    3) 形式参数也是局部变量。<strong>实参给形参传值的过程也就是给局部变量赋值的过程</strong>。<br>    4) 在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为<code>“分程序”</code> 或 <code>“语句块”</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;          <span class="comment">/* a, b 在整个本函数内 有效*/</span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c;         <span class="comment">/* c 只在当前&#123;&#125; 内有效*/</span></span><br><span class="line">c = a+b;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量c只在复合语句（程序块）内有效，离开该复合语句该变量就无效，释放内存。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内部定义的变量是<strong>局部变量</strong>，而在函数之外定义的而变量称为外部变量，外部变量是<strong>全局变量</strong>（也称全程变量）。全局变量可以为本文件中其他函数所共用。它的有效范围为从定义变量的位置开始到本源文件结束。</p><p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p=<span class="number">1</span>, q=<span class="number">5</span>;               <span class="comment">/*  p, q 在整个源文件中有效 */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b, c;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1, c2;                <span class="comment">/*  外部变量 c1, c2 在此位置到文件结尾有效  */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了便于区分局部变量和全局变量，在C程序设计人员中有一个习惯（但非规定），将全局变量名的第一个字母用大写表示。</p><p>说明：<br>    1) 设置全局扁郎是增加了函数间数据联系的取到。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值，就能狗影响到其他函数，相当于各个函数间有直接的传递通道。由于函数的调用只能带回一个返回值，因此有时候可以利用全局变量增加函数间的联系通道，通过函数调用能够得到一个以上的值。<br>    2) 建议不在必要时不要使用全局变量，原因如下<br>        ① 全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元。<br>        ② 它是函数的通用性降低了，因为函数在执行时要依赖于其所在的外部变量。如果将一个函数移植到另一个文件中，还要将有关的外部变量及值一起移植过去。但若该外部变量与其他文件与其他文件的变量名冲突时，就会出现问题，降低了程序的可靠性和通用性。在程序设计中，在划分模块式要求模块的<code>**内聚性**</code>强、与其他模块的<code>**耦合性**</code>弱。即模块的功能要单一（不要把许多互不相干的功能放到一个模块中），与其他模块的相互影响要尽量少，而用全局变量是不符合这个原则的。一般要求把c程序中的函数做成一个封闭体，除了可以通过<code>实参——形参</code>的渠道与外界发生联系外，没有其他渠道。这样的程序移植性好，可读性强。<br>        ③ 使用全局变量过多，会降低程序的清晰性，人们往往难以清楚的判断出每个瞬时各个外部变量的值。在各个函数执行时都有坑呢改变外部变量的值，程序容易出错。因此，要限制使用外部变量<br>        ④ 如果在同一个源文件件中，外部变量与局部变量同名，则在局部变量的作用范围内，外部变量被<code>屏蔽</code>，即它不起作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;局部变量&quot;&gt;&lt;a href=&quot;#局部变量&quot; class=&quot;headerlink&quot; title=&quot;局部变量&quot;&gt;&lt;/a&gt;局部变量&lt;/h4&gt;&lt;p&gt;在一个函数内部定义的变量称为&lt;strong&gt;局部变量&lt;/strong&gt;，它的作用域仅限于该函数内，也就是说只有本函数内才能使用它们，在此函数以外是不能使用这些变量的。&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://yulongphp.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://yulongphp.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c语言输入和输出</title>
    <link href="http://yulongphp.github.io/2015/05/31/c%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/"/>
    <id>http://yulongphp.github.io/2015/05/31/c语言输入和输出/</id>
    <published>2015-05-31T09:36:18.000Z</published>
    <updated>2018-08-22T09:43:49.629Z</updated>
    
    <content type="html"><![CDATA[<h4 id="C语言在显示器上输出数据"><a href="#C语言在显示器上输出数据" class="headerlink" title="C语言在显示器上输出数据"></a>C语言在显示器上输出数据</h4><p>在C语言中，有三个函数可以用来在显示器上输出数据：<br>puts()：只能输出字符串，在《C语言在屏幕上显示内容》中已经进行了介绍。<br>putchar()：只能输出单个字符，本节将会介绍。<br>printf()：可以输出各种类型的数据，在《在屏幕上输出各种类型的数据》《C语言中的整数》中都进行了介绍，本节要进行更加深入的讲解。</p><a id="more"></a><p>printf() 是最灵活、最复杂、最常用的输出函数，完全可以替代 puts() 和 putchar()，大家一定要掌握。<br>putchar()</p><p>putchar() 函数只能用来输出单个字符，例如：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    putchar(<span class="string">'a'</span>)<span class="comment">;</span></span><br><span class="line">    putchar(<span class="number">7</span>)<span class="comment">;</span></span><br><span class="line">    putchar(<span class="string">'\x46'</span>)<span class="comment">;</span></span><br><span class="line">    system(<span class="string">"pause"</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出 aF，同时会听到喇叭发出“嘟”的声音。<br>关于换行</p><p>puts() 函数在输出结束时会自动换行，而 printf() 和 putchar() 不会，需要手动添加换行符\n。如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"c.biancheng.net"</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'Z'</span>;</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n);</span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>c.biancheng.net<br>Z100Z请按任意键继续. . .<br>printf() 的高级用法</p><p>这一节的内容有些繁杂，如果你希望加快学习进度，尽早写出有趣的代码，也可以跳过这节，后面遇到不懂的 printf 输出再来回顾。<br>虽然我们已经熟悉了 printf，但是还没有把它发挥到极致，printf 可以有更加“炫酷”的输出。</p><p>假如现在老师要求我们用C语言输出一个 4×4 的整数矩阵，为了增强阅读性，数字要对齐，怎么办呢？我们显然可以这样来做：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">a1</span>=20, <span class="attribute">a2</span>=345, <span class="attribute">a3</span>=700, <span class="attribute">a4</span>=22;</span><br><span class="line">    int <span class="attribute">b1</span>=56720, <span class="attribute">b2</span>=9999, <span class="attribute">b3</span>=20098, <span class="attribute">b4</span>=2;</span><br><span class="line">    int <span class="attribute">c1</span>=233, <span class="attribute">c2</span>=205, <span class="attribute">c3</span>=1, <span class="attribute">c4</span>=6666;</span><br><span class="line">    int <span class="attribute">d1</span>=34, <span class="attribute">d2</span>=0, <span class="attribute">d3</span>=23, <span class="attribute">d4</span>=23006783;</span><br><span class="line">    printf(<span class="string">"%d        %d       %d       %d\n"</span>, a1, a2, a3, a4);</span><br><span class="line">    printf(<span class="string">"%d     %d      %d     %d\n"</span>, b1, b2, b3, b4);</span><br><span class="line">    printf(<span class="string">"%d       %d       %d         %d\n"</span>, c1, c2, c3, c4);</span><br><span class="line">    printf(<span class="string">"%d        %d         %d        %d\n"</span>, d1, d2, d3, d4);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>20        345       700       22<br>56720     9999      20098     2<br>233       205       1         6666<br>34        0         23        23006783<br>矩阵一般在大学的《高等数学》中会讲到，m×n 的数字矩阵可以理解为把 m×n 个数字摆放成 m 行 n 列的样子。<br>看，这是多么地自虐，要敲那么多空格，还要严格控制空格数，否则输出就会错位。</p><p>类似的需求随处可见，整齐的格式会更加美观，让人觉得生动有趣。我们大可不必像上面一样，printf 可以更好的控制输出格式。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">a1</span>=20, <span class="attribute">a2</span>=345, <span class="attribute">a3</span>=700, <span class="attribute">a4</span>=22;</span><br><span class="line">    int <span class="attribute">b1</span>=56720, <span class="attribute">b2</span>=9999, <span class="attribute">b3</span>=20098, <span class="attribute">b4</span>=2;</span><br><span class="line">    int <span class="attribute">c1</span>=233, <span class="attribute">c2</span>=205, <span class="attribute">c3</span>=1, <span class="attribute">c4</span>=6666;</span><br><span class="line">    int <span class="attribute">d1</span>=34, <span class="attribute">d2</span>=0, <span class="attribute">d3</span>=23, <span class="attribute">d4</span>=23006783;</span><br><span class="line">    printf(<span class="string">"%-9d %-9d %-9d %-9d\n"</span>, a1, a2, a3, a4);</span><br><span class="line">    printf(<span class="string">"%-9d %-9d %-9d %-9d\n"</span>, b1, b2, b3, b4);</span><br><span class="line">    printf(<span class="string">"%-9d %-9d %-9d %-9d\n"</span>, c1, c2, c3, c4);</span><br><span class="line">    printf(<span class="string">"%-9d %-9d %-9d %-9d\n"</span>, d1, d2, d3, d4);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>20        345       700       22<br>56720     9999      20098     2<br>233       205       1         6666<br>34        0         23        23006783<br>这样写起来更加方便，即使改变某个数字，也无需修改 printf 语句。</p><p>%-9d中，d表示以十进制输出，9表示最少占9个字符的宽度，宽度不足以空格补齐，-表示左对齐。综合起来，%-9d表示以十进制输出，左对齐，宽度最小为9个字符。大家可以亲自试试%9d的输出效果。</p><p>printf 格式控制字符的完整形式如下：</p><pre><code>%[flags][width][.precision]type</code></pre><blockquote><p>[xxx] 并不是C语言规定的格式，只是一种习惯写法，表示此处的内容可有可无，后面会经常见到这样的写法。</p></blockquote><p>1) type 也就是以什么类型输出，比如 %d、%f、%c，type 就分别对应 d、f、c；%-9d中 type 对应 d。type 必须有。</p><p>2) width 表示最小输出宽度，也就是占几个字符的位置；%-9d中 width 对应 9。</p><p>对于整数和小数，默认右对齐，不足的宽度以空格补齐，例如：<br>printf(“%10d%12f”, 234, 9.8);<br>输出结果为：<br>       234    9.800000<br>234 前面共有7个空格，9.8 前面有4个空格。</p><p>3) .precision 表示输出精度。</p><p>对于 %d，.precision 表示的其实是最小输出宽度，与 width 不同的是，不足的宽度以 0 补齐，例如：<br>printf(“%.10d\n”, 4309);<br>输出结果为：<br>0000004309</p><p>对于 %f，.precision 表示小数的位数，不足以 0 补齐，也就是精度，例如：<br>printf(“%.10f %.3f\n”, 23.988, 2.9328745);<br>输出结果为：<br>23.9880000000 2.933</p><p>4) flags 是标志字符，<code>%-9d</code>中 flags 对应<code>-</code>。</p><p>几种常见的标志字符<br><img src="/images/cFlags.png" alt=""></p><blockquote><p>有兴趣的读者可以猛击这里查看更多关于 printf 的输出格式。<br>printf 的这些格式规范不是“小把戏”，优美的输出格式随处可见，例如 dos 下的 dir 命令，会整齐地列出当前目录下的文件：<br><img src="/images/dosDir.png" alt=""></p></blockquote><h4 id="C语言从键盘输入数据"><a href="#C语言从键盘输入数据" class="headerlink" title="C语言从键盘输入数据"></a>C语言从键盘输入数据</h4><p>程序是人机交互的媒介，有输出必然也有输入。在C语言中，有多个函数可以从键盘获得用户输入：</p><ul><li>scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。</li><li>getchar()、getche()、getch()：这三个函数都用于输入单个字符。</li><li>gets()：获取一行数据，并作为字符串处理。</li></ul><p>scanf() 是最灵活、最复杂、最常用的输入函数，但它不能完全取代其他函数，大家都要有所了解。<br>scanf()函数</p><p>scanf 是 scan format 的缩写，意思是格式化扫描，也就是从键盘获得用户输入。我们先来看一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);  <span class="comment">//输入整数并赋值给变量a</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);  <span class="comment">//输入整数并赋值给变量b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a+b=%d\n"</span>, a+b);  <span class="comment">//计算a+b的值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;c, &amp;d);  <span class="comment">//输入两个整数并分别赋值给c、d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c*d=%d\n"</span>, c*d);  <span class="comment">//计算c*d的值</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>12↙<br>60↙<br>a+b=72<br>10 23↙<br>c*d=230</p><blockquote><p>↙表示按下回车键。</p></blockquote><p>从键盘输入12，按下回车键，scanf() 就会读取输入数据并赋值给变量 a，本次输入结束，执行下一条语句。接着给变量b赋值，也是同样的道理。</p><p>第9行代码中，我们同时输入两个整数并分别赋值给c、d。注意”%d %d”之间是有空格的，所以输入数据时也要有空格。也就是说，输入数据的格式要和控制字符串的格式一致。</p><p>scanf 和 printf 非常相似：<br>scanf(“%d %d”, &amp;a, &amp;b);  // 获取用户输入的两个整数，分别赋值给变量 a 和 b<br>printf(“%d %d”, a, b);  // 将变量 a 和 b 的是在显示器上输出。<br>它们都有格式控制字符串，都有变量列表。不同的是，scanf 的变量前要带一个<code>&amp;</code>符号；&amp;称为<strong>取地址符</strong>，也就是获取变量在<strong>内存中的地址</strong>。</p><p>在《二进制思想以及数据的存储》一节中讲到，数据是以二进制的形式保存在内存中的，字节（Byte）是最小的可操作单位。为了便于管理，我们给每个字节分配了一个编号，使用该字节时，只要知道编号就可以，就像每个学生都有学号，老师会随机抽取学号来让学生回答问题。字节的编号是有顺序的，从 0 开始，接下来是 1、2、3……</p><p>下图是 4G 内存中每个字节的编号（以十六进制表示）：<br><img src="/images/hexMemory.png" alt=""></p><p>这个编号，就叫做<code>地址（Address）</code>。<code>int a</code>;会在内存中分配四个字节的空间，我们将第一个字节的地址称为变量 a 的地址，也就是<code>&amp;a</code>的值。对于前面讲到的整数、浮点数、字符，都要使用 &amp; 获取它们的地址，scanf 会根据地址把读取到的数据写入内存。</p><p>我们不妨将它们的地址输出看一下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="string">'F'</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">452</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a=%#x, &amp;b=%#x, &amp;c=%#x\n"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>&amp;a=0x18ff48, &amp;b=0x18ff44, &amp;c=0x18ff40</p><p><img src="/images/memoryAddress.png" alt=""></p><p>图：a、b、c 的内存地址</p><blockquote><p>注意：你看到的地址是虚拟地址，并不等于它在物理内存中的地址。虚拟内存是现代操作系统因内存管理的需要才提出的概念，dos 下没有这个概念，用户看到的都是真实的地址。CPU 操作的是物理内存地址，所以虚拟地址必须经过转换才能交给 CPU，这是 OS 的工作，对用户是透明的。</p></blockquote><p>再来看一个 scanf 的例子：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    scanf(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a+b=%d\n"</span>, a+b);</span><br><span class="line">    scanf(<span class="string">"%d   %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a+b=%d\n"</span>, a+b);</span><br><span class="line">    scanf(<span class="string">"%d, %d, %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a+b+c=%d\n"</span>, a+b+c);</span><br><span class="line">   </span><br><span class="line">    scanf(<span class="string">"%d is bigger than %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a-b=%d\n"</span>, a-b);</span><br><span class="line">    <span class="keyword">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>10    20↙<br>a+b=30<br>100 200↙<br>a+b=300<br>56,45,78↙<br>a+b+c=179<br>25 is bigger than 11↙<br>a-b=14</p><p>第一个 scanf() 的格式控制字符串为<code>&quot;%d %d&quot;</code>，中间有一个空格，而我们却输入了<code>10    20</code>，中间有多个空格。<br>第二个 scanf() 的格式控制字符串为<code>&quot;%d   %d&quot;</code>，中间有多个空格，而我们却输入了<code>100 200</code>，中间只有一个空格。这说明 scanf() 对输入数据之间的空格的处理比较宽松，并不要求空格数严格对应。</p><p>第三个 scanf() 的控制字符串为<code>&quot;%d, %d, %d&quot;</code>，中间以逗号分隔，所以输入的整数也要以逗号分隔。</p><p>第四个 scanf() 要求整数之间以<code>is bigger than</code>分隔。</p><p>每次用户按下回车键，程序就会认为用户输入结束，scanf() 开始读取用户输入的内容，并根据格式控制字符串从中提取数据，只要用户输入的内容和格式控制字符串匹配，就能够正确提取。</p><p>本质上讲，用户输入的内容都是字符串，scanf() 完成的是从字符串中提取有效数据的过程。<br>输入单个字符</p><p>scanf 用于接收用户输入的各种数据，如果仅仅是输入单个字符，也可以使用 getchar()、getche() 或 getch()。</p><p>getchar() 使用示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    c=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c='%c'\n"</span>, c);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p>#↙<br>c=’#’</p><p>你也可以将第5、6行的语句合并为一个：</p><pre><code>char c = getchar();</code></pre><p>getche() 使用示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=getche();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c='%c'\n"</span>, c);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p>#c=’#’</p><p>大家亲自运行程序会发现，刚输入字符 #，getche() 就立即获取，不会等到用户按下回车键，所以运行结果中没有换行。而 getchr() 不是，它要等到用户按下回车键才能确认输入结束，所以运行结果中有换行。</p><blockquote><p>conio.h不是C标准库中的头文件，在ISO和POSIX标准中均没有定义。conio是Console Input/Output（控制台输入输出）的简写，其中定义了通过控制台进行数据输入和数据输出的函数，主要是一些用户通过按键盘产生的对应操作，比如getch()函数等等。大部分DOS，Windows，PharLap，DOSX，OS/2等平台上的C编译器提供此文件，UNIX和Linux平台的C编译器本身通常不包含此头文件，但已经有其兼容，可参考：<a href="http://conio.sourceforge.net/。" target="_blank" rel="noopener">http://conio.sourceforge.net/。</a><br>   另外大家平时主要是利用conio.h这个头文件中的getch()函数，即读取键盘字符但是不显示出来（without echo)，但是含有conio.h的程序在linux无法直接编译通过，因为linux没有这个头文件，除了利用上述的兼容包外还可以在linux采用原生的方法达到同样的效果，那就是利用linux系统的命令stty –echo，它代表不显示输入内容，源代码如下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Input a char:"</span>);</span><br><span class="line">system(<span class="string">"stty -echo"</span>);</span><br><span class="line">c=getchar();</span><br><span class="line">system(<span class="string">"stty echo"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You have inputed:%c \n"</span>,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getch() 使用示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=getch();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c='%c'\n"</span>, c);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输入 #，结果为：<br>c=’#’</p><p>大家亲自运行程序会发现，getch() 和 getche() 类似，输入一个字符就立即获取，不会等待用户按下回车键。与 getche() 不同的是，getch() 输入的 # 并没有显示出来。</p><p>在C语言中，将用户输入的内容显示在屏幕上叫做回显（Echo）。getchar()、getche() 是有回显的，而 getch() 没有回显。</p><p>回显在大部分情况下是有必要的，它能够与用户及时交互，让用户清楚地看到自己输入的内容。但在某些特殊情况下，我们却不希望有回显，例如输入密码，有回显是非常危险的，容易被偷窥。</p><p>另外需要注意的是：getchar() 位于 stdio.h 头文件中，是C语言规定的标准函数；而 getche()、getch() 位于 conio.h 中，它们都不是标准函数，不保证在任何编译器下都有效。<br>输入字符串</p><p>这里由于大家的基础知识还不够，没有学到数组和指针，暂时无法深入讲解。下面仅作一个演示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">30</span>], str2[<span class="number">30</span>];  <span class="comment">//定义两个字符数组</span></span><br><span class="line">    gets(str1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str2);</span><br><span class="line">    <span class="built_in">puts</span>(str1);</span><br><span class="line">    <span class="built_in">puts</span>(str2);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>The world is beautiful!↙<br>Hello World!↙<br>The world is beautiful!<br>Hello</p><p>gets() 会读取用户输入的整行内容，包括空格。而 scanf() 遇到空格就结束读取，也就是说，使用 scanf() 读取的字符串中永远不会包含空格。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;C语言在显示器上输出数据&quot;&gt;&lt;a href=&quot;#C语言在显示器上输出数据&quot; class=&quot;headerlink&quot; title=&quot;C语言在显示器上输出数据&quot;&gt;&lt;/a&gt;C语言在显示器上输出数据&lt;/h4&gt;&lt;p&gt;在C语言中，有三个函数可以用来在显示器上输出数据：&lt;br&gt;puts()：只能输出字符串，在《C语言在屏幕上显示内容》中已经进行了介绍。&lt;br&gt;putchar()：只能输出单个字符，本节将会介绍。&lt;br&gt;printf()：可以输出各种类型的数据，在《在屏幕上输出各种类型的数据》《C语言中的整数》中都进行了介绍，本节要进行更加深入的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yulongphp.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://yulongphp.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c语言变量和数据类型</title>
    <link href="http://yulongphp.github.io/2015/05/18/c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yulongphp.github.io/2015/05/18/c语言变量和数据类型/</id>
    <published>2015-05-18T07:09:41.000Z</published>
    <updated>2018-08-22T09:43:49.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h4><p>Linux下使用最广泛的C/C++编译器是GCC，大多数的Linux发行版本都默认安装，不管是开发人员还是初学者，一般都将GCC作为Linux下首选的编译工具。</p><p>保存文件后退出，打开终端并 cd 到当前目录，输入下面的命令：</p><pre><code>gcc test.c -o test</code></pre><p>可以直接将C代码编译链接为可执行文件。<br><a id="more"></a></p><p>可以看到在当前目录下多出一个文件 test，这就是可执行文件。不像Windows，Linux不以文件后缀来区分可执行文件，Linux下的可执行文件后缀理论上是可以任意更改的。</p><p>当然，也可以分步编译：</p><p>1) 预处理</p><pre><code>gcc -E test.c -o test.i</code></pre><p>在当前目录下会多出一个预处理结果文件 test.i，打开 test.i 可以看到，在 test.c 的基础上把stdio.h和stdlib.h的内容插进去了。</p><p>2) 编译为汇编代码</p><pre><code>gcc -S test.i -o test.s</code></pre><p>其中-S参数是在编译完成后退出，-o为指定文件名。</p><p>3) 汇编为目标文件</p><pre><code>gcc -c test.s -o test.o</code></pre><p>.o就是目标文件。目标文件与可执行文件类似，都是机器能够识别的可执行代码，但是由于还没有链接，结构会稍有不同。</p><p>3) 链接并生成可执行文件</p><pre><code>gcc test.o -o test</code></pre><p>如果有多个源文件，可以这样来编译：</p><pre><code>gcc -c test1.c -o test1.o    gcc -c test2.c -o test2.o    gcc test1.o test2.o -o test</code></pre><p>注意：如果不指定文件名，GCC会生成名为a.out的文件，.out文件只是为了区分编译后的文件，Linux下并没有标准的可执行文件后缀名，一般可执行文件都没有后缀名。</p><p>编译后生成的test文件就是程序了，运行它：</p><pre><code>./test</code></pre><p>如果没有运行权限，可以使用sudo命令来增加权限（注意要在Linux的分区下）：</p><pre><code>sudo cdmod test 777</code></pre><p>对于程序的检错，我们可以用-pedantic、-Wall、-Werror选项：<br>-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码（并不是全部）；<br>-Wall可以让gcc显示警告信息；<br>-Werror可以让gcc在编译中遇到错误时停止继续。</p><p>这3个选项都是非常有用的。</p><h4 id="c语言转义字符"><a href="#c语言转义字符" class="headerlink" title="c语言转义字符"></a>c语言转义字符</h4><p>通过puts可以输出字符串，例如：</p><pre><code>puts(&quot;123abc&quot;);</code></pre><p>“123abc” 对应的ASCII码值的八进制分别是 61、62、63、141、142、143，上面的代码也可以写为：</p><pre><code>puts(&quot;\61\62\63\141\142\143&quot;);</code></pre><p>在C语言中，所有的ASCII码都可以用反斜杠\加数字（默认是8进制）来表示，称为转义字符（Escape Character），因为\后面的字符都不是它原来的ASCII字符的意思了。</p><p>除了八进制，也可以用十六进制来表示。用十六进制表示时数字要以x开头。”123abc” 对应的ASCII码值的十六进制分别是 31、32、33、61、62、63，所以也可以写为：</p><pre><code>puts(&quot;\x31\x32\x33\x61\x62\x63&quot;);</code></pre><p>注意：只能使用八进制或十六进制，不能使用十进制。<br>一个完整的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"The string is: \61\62\63\x61\x62\x63"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>The string is: 123abc</p><p>在ASCII码中，从 0~31（十进制）的字符为控制字符，它们都是看不见的字符，不能在显示器上显示，也没法书写，只能以转义字符的形式来表示。不过，直接使用ASCII码值记忆不方便，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下：</p><p>转义字符    意义  ASCII码值（十进制）<br>\a  响铃(BEL) 007<br>\b  退格(BS) ，将当前位置移到前一列  008<br>\f  换页(FF)，将当前位置移到下页开头  012<br>\n  换行(LF) ，将当前位置移到下一行开头    010<br>\r  回车(CR) ，将当前位置移到本行开头 013<br>\t  水平制表(HT) （跳到下一个TAB位置）   009<br>\v  垂直制表(VT)    011</p><p>转义字符示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"C\tC++\tJava\nC first appeared!\a"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>C       C++     Java<br>C first appeared!<br>同时会听到喇叭发出“嘟”的声音，这是使用\a的效果。</p><h4 id="C语言中的空白符"><a href="#C语言中的空白符" class="headerlink" title="C语言中的空白符"></a>C语言中的空白符</h4><p>空格、制表符、换行符统称为空白符，它们只能占位，没有实际的内容。<br>制表符也称缩进，就是Tab键，默认占用4个空格的位置，你也可以在编辑器中修改。<br>对于编译器，有的空白符会被忽略，有的却不能。请看下面几种 puts 的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"C语言"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"中文网"</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span></span><br><span class="line">    (<span class="string">"C语言中文网"</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span></span><br><span class="line">    (</span><br><span class="line">    <span class="string">"C语言中文网"</span></span><br><span class="line">    )</span><br><span class="line">    ;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span>   (<span class="string">"C语言中文网"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>    (    <span class="string">"C语言中文网"</span>    )    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>C语言<br>中文网<br>C语言中文网<br>C语言中文网<br>C语言中文网<br>C语言中文网</p><p>看到输出结果，说明代码没有错误，以上几种 puts 的用法是正确的。puts和()之间、” “和()之间可以有任意的空白符，它们会被编译器忽略，编译器不认为它们是代码的一部分，它们的存在只是在编辑器中呈现一定的格式，让程序员阅读方便。</p><p>需要注意的是：字符串中的空格和制表符不会被忽略，它们会被输出到控制台上。并且字符串中不能有换行符，否则会产生编译错误。请看下面的代码：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">"C语  言 中文网"</span>)<span class="comment">;</span></span><br><span class="line">    puts(<span class="string">"C语言</span></span><br><span class="line"><span class="string">    中文网"</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第5~6行代码是错误的，字符串必须在一行内结束，不能换行。把这两行代码删除，运行结果为：</p><p>C语  言 中文网</p><p>程序员要善于利用空白符：缩进（制表符）和换行可以让代码结构更加清晰，空格可以让代码看起来不那么拥挤。专业的程序员同样追求专业的代码格式，大家在以后的学习中可以慢慢体会。</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。在C语言中，有多种数据类型，例如：<br>说  明    字符型 短整型 整型  长整型 单精度浮点型  双精度浮点型  无类型<br>数据类型    char    short   int long    float   double  void</p><p>这些是最基本的数据类型，是C语言自带的，如果我们需要，还可以通过它们组成更加复杂的数据类型，后面我们会一一讲解。</p><h5 id="数据的长度（Length）"><a href="#数据的长度（Length）" class="headerlink" title="数据的长度（Length）"></a>数据的长度（Length）</h5><p>所谓数据长度（Length），是指数据占用多少个字节。占用的字节越多，能存储的数据就越多，对于数字来说，值就会更大，反之能存储的数据就有限。</p><p>多个数据在内存中是连续存储的，彼此之间没有明显的界限，如果不明确指明数据的长度，计算机就不知道何时存取结束。例如我们保存了一个整数 1000，它占用4个字节的内存，而读取时却认为它占用3个字节或5个字节，这显然是不正确的。</p><p>所以，在定义变量时还要指明数据的长度。而这恰恰是数据类型的另外一个作用。数据类型除了指明数据的解释方式，还指明了数据的长度。因为在C语言中，每一种数据类型所占用的字节数都是固定的，知道了数据类型，也就知道了数据的长度。</p><p>在32位环境中，各种数据类型的长度一般如下：<br>说  明    字符型 短整型 整型  长整型 单精度浮点型  双精度浮点型<br>数据类型    char    short   int long    float   double<br>长  度    1   2   4   4   4   8<br>C语言有多少种数据类型，每种数据类型长度是多少、该如何使用，这是每一位C程序员都必须要掌握的，后续我们会一一讲解。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>数据是放在内存中的，在内存中存取数据要明确三件事情：数据存储在哪里、数据的长度以及数据的处理方式。</p><p>变量名不仅仅是为数据起了一个好记的名字，还告诉我们数据存储在哪里，使用数据时，只要提供变量名即可；而数据类型则指明了数据的长度和处理方式。所以诸如int n;、char c;、float money;这样的形式就确定了数据在内存中的所有要素。</p><p>C语言提供的多种数据类型让程序更加灵活和高效，同时也增加了学习成本。而有些编程语言，例如PHP、JavaScript等，在定义变量时不需要指明数据类型，编译器会根据赋值情况自动推演出数据类型，更加智能。</p><p>除了C语言，Java、C++、C#等在定义变量时也必须指明数据类型，这样的编程语言称为强类型语言。而PHP、JavaScript等在定义变量时不必指明数据类型，编译系统会自动推演，这样的编程语言称为弱类型语言。</p><p>强类型语言一旦确定了数据类型，就不能再赋给其他类型的数据，除非对数据类型进行转换。弱类型语言没有这种限制，一个变量，可以先赋给一个整数，然后再赋给一个字符串。</p><p>最后需要说明的是：数据类型只在定义变量时指明，而且必须指明；使用变量时无需再指明，因为此时的数据类型已经确定了。</p><h4 id="在屏幕上输出各种数据类型"><a href="#在屏幕上输出各种数据类型" class="headerlink" title="在屏幕上输出各种数据类型"></a>在屏幕上输出各种数据类型</h4><p>在《C语言在屏幕上显示内容》一节中，我们使用 puts 来输出字符串。puts 是 output string 的缩写，只能用来输出字符串，不能输出整数、小数、字符等，我们需要用另外一个函数，那就是 printf<br>printf 比 puts 更加强大，不仅可以输出字符串，还可以输出整数、小数、单个字符等；输出格式也可以自己定义，例如：<br>以十进制、八进制、十六进制形式输出；<br>要求输出的数字占 n 个字符的位置；<br>控制小数的位数。</p><p>printf 是 print format 的缩写，意思是“格式化打印”。这里所谓的“打印”就是在屏幕上显示内容，与“输出”的含义相同，所以我们一般称 printf 是用来格式化输出的。<br>先来看一个简单的例子：<br>printf(“C语言中文网”);<br>这个语句可以在屏幕上显示“C语言中文网”，与puts(“C语言中文网”);的效果类似。</p><p>输出变量 abc 的值：<br>int abc=999;<br>printf(“%d”, abc);<br>这里就比较有趣了。先来看%d，d 是 decimal 的缩写，意思是十进制数，%d 表示以十进制的形式输出。输出什么呢？输出变量 abc 的值。%d 与 abc 是对应的，也就是说，会用 abc 的值来替换 %d。</p><p>%d 与后面的变量是一一对应的，第一个 %d 对应第一个变量，第二个 %d 对应第二个变量……</p><p>%d称为格式控制符，它指明了以何种形式输出数据。格式控制符均以%开头，后跟其他字符。%d 表示以十进制形式输出一个整数。除了 %d，printf 支持更多的格式控制，例如：<br>%c：输出一个字符。c 是 character 的简写。<br>%s：输出一个字符串。s 是 string 的简写。<br>%f：输出一个小数。f 是 float 的简写。<br>除了这些，printf 支持更加复杂和优美的输出格式，考虑到读者的基础暂时不够，我们将在《printf的高级用法》一节中展开讲解。</p><p>我们把代码补充完整，体验一下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'@'</span>;  <span class="comment">//字符用单引号包围，字符串用双引号包围</span></span><br><span class="line">    <span class="keyword">float</span> money = <span class="number">93.96</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n=%d, c=%c, money=%f\n"</span>, n, c, money);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>n=100, c=@, money=93.959999</p><p>要点提示：<br>1) \n表示换行，在《C语言转义字符》一节中有具体讲解。<em>puts 输出完成后会自动换行</em>，而 <em>printf 不会，要自己添加换行符</em>。</p><p>2) //后面的为注释。注释用来说明代码是什么意思，让我们阅读更加方便，它也是代码的一部分。编译器会忽略注释内容。</p><h4 id="C语言中的整数（short-int-long）"><a href="#C语言中的整数（short-int-long）" class="headerlink" title="C语言中的整数（short,int,long）"></a>C语言中的整数（short,int,long）</h4><p>整数是编程中常用的一种数据，C语言中有三种整数类型，分别为 short、int 和 long。int 称为整型，short 称为短整型，long 称为长整型，它们的长度（所占字节数）关系为：<br>short &lt;= int &lt;= long<br>它们具体占用几个字节C语言并没有规定，C语言只做了宽泛的限制：<br>short 至少占用2个字节。<br>int 建议为一个机器字长。32位环境下机器字长为4字节，64位环境下机器字长为8字节。<br>short 的长度不能大于 int，long 的长度不能小于 int。</p><p>这就意味着，short 并不一定真的”短“，long 也并不一定真的”长“，它们有可能和 int 占用相同的字节数。决定整数长度的因素很多，包括硬件（CPU和数据总线）、操作系统、编译器等。</p><p>在16位环境下，short 为2个字节，int 为2个字节，long 为4个字节。16位环境多用于单片机和低级嵌入式系统，在PC和服务器上基本都看不到了。</p><p>对于32位的 Windows、Linux 和 OS X，short 为2个字节，int 为4个字节，long 也为4个字节。PC和服务器上的32位系统占有率也在慢慢下降，嵌入式系统使用32位越来越多。</p><p>在64位环境下，不同的操作系统会有不同的结果，如下所示（长度以字节计）：<br>操作系统    short   int long<br>Win64   2   4   4<br>类Unix系统（包括 Unix、Linux、OS X、BSD、Solaris 等）   2   4   8<br>目前我们使用较多的PC系统为 Win XP、Win 7、Win 8、Win 10、Mac OS X、Linux，short 和 int 的长度都是固定的，分别为2和4，大家可以放心使用，long 的长度在 Win64 和类Unix系统下会有所不同，使用时要注意移植性</p><p>获取某个数据类型的长度可以使用 sizeof 操作符，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">long</span> c = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">'X'</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> a_length = <span class="keyword">sizeof</span> a;</span><br><span class="line">    <span class="keyword">int</span> b_length = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d, b=%d, c=%d, d=%d\n"</span>, a_length, b_length, <span class="keyword">sizeof</span>(c), <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Win7下的运行结果为：<br>a=2, b=4, c=4, d=1</p><p>sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略 ( )，如果跟的是数据类型，就必须带上 ( )。</p><p>需要注意的是，sizeof 是C语言中的操作符，不是函数，所以可以不带 ( )，后面会详细讲解。</p><h5 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h5><p>在数学中，数字有正负之分。在C语言中也是一样，short、int、long 都可以带上符号，例如：<br>short a = -10;  //负数<br>int b = +10;  //正数<br>long c = (-9) + (+12);  //负数和正数相加<br>如果不带正负号，默认就是正数。</p><p>符号也要在内存中体现出来。符号只有正负两种情况，用1位就足以表示，这1位就是最高位。以 int 为例，它占用32位的内存，0~30位表示数值，31 位表示正负号。如下图所示：</p><p>在编程语言中，计数往往是从0开始，例如字符串 “abc123”，我们称第 0 个字符是 a，第 1 个字符是 b，第 5 个字符是 3。这和我们平时从 1 开始计数的习惯不一样，大家要慢慢适应，培养编程思维。<br>在符号位中，用0表示正数，用1表示负数。例如 short 类型的 -10、+16 在内存中的表示如下：</p><p>如果不希望设置符号位，可以在数据类型前面加 unsigned，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">1002</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c = <span class="number">9892320</span>;</span><br></pre></td></tr></table></figure></p><p>这样，short、int、long 中就没有符号位了，所有的位都用来表示数值。也就意味着，使用了 unsigned 只能表示正数，不能表示负数了。</p><p>如果是unsigned int，那么可以省略 int ，只写 unsigned，例如：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unsigned n</span> = 100;</span><br></pre></td></tr></table></figure></p><p>它等价于：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>输出无符号数使用%u，代码如下<br>如果是unsigned int，那么可以省略 int ，只写 unsigned，例如：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unsigned n</span> = 100;</span><br></pre></td></tr></table></figure></p><p>它等价于：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>输出无符号数使用%u，代码如下：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1234</span>;</span><br><span class="line">    unsigned a1=<span class="number">1234</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0x80000000</span>;  <span class="regexp">//</span> <span class="number">0x80000000</span> = <span class="number">0x7fffffff</span> + <span class="number">0x1</span></span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">0xffffffff</span>;</span><br><span class="line">    unsigned e=<span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a=%d, a(u)=%u\n"</span>, a, a);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a1=%d, a1(u)=%u\n"</span>, a1, a1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"b=%d, b(u)=%u\n"</span>, b, b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"c=%d, c(u)=%u\n"</span>, c, c);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"d=%d, d(u)=%u\n"</span>, d, d);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"e=%d, e(u)=%u\n"</span>, e, e);</span><br><span class="line">    <span class="keyword">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>a=1234, a(u)=1234<br>a1=1234, a1(u)=1234<br>b=2147483647, b(u)=2147483647<br>c=-2147483648, c(u)=2147483648<br>d=-1, d(u)=4294967295<br>e=-1, e(u)=4294967295</p><p>可以发现，无论变量声明为有符号数还是无符号数，只有当以 %u 格式输出时，才会作为无符号数处理；如果声明为 unsigned，却以 d% 输出，那么也是有符号数。</p><blockquote><p>d、e 的输出值之所以为 -1，与它们在内存中的存储形式有关，我们将在《C语言整数在内存中的存储》一节中详细介绍</p></blockquote><h5 id="取值范围和数据溢出"><a href="#取值范围和数据溢出" class="headerlink" title="取值范围和数据溢出"></a>取值范围和数据溢出</h5><p>short、int、long 占用的字节数不同，所能表示的数值范围也不同。以32位平台为例，下面是它们的取值范围：<br>数据类型    所占字节数   取值范围<br>short   2   -32768~32767，即 -215~(215-1)<br>unsigned short  2   0~65535，即 0~(216-1)<br>int 4   -2147483648~2147483647，即 -231~(231-1)<br>unsigned int    4   0~4294967295，即0~(232-1)<br>long    4   -2147483648~2147483647，即 -231~(231-1)<br>unsigned long   4   0~4294967295，即0~(232-1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">0x100000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%u\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>a=0<br>变量 a 为 int 类型，占用4个字节（32位），能表示的最大值为 0xFFFFFFFF，而 0x100000000 = 0xFFFFFFFF + 1，占用33位，已超出 a 所能表示的最大值，会发生溢出，最高位被截去，剩下的32位都是0。也就是说，在 a 被输出前，其值已经变成了 0<br>整数的前缀</p><p>在程序中是根据前缀来区分十进制、八进制和十六机制的。</p><p>1) 十进制数由 0~9 十个数字组成，没有前缀。例如：<br>合法的十进制数：237、-568、65535、1627；<br>不合法的十进制数：023（不能有前导0）、23D（含有非十进制数码）。</p><p>2) 八进制数由 0~7 八个数字组成，必须以0开头，即以0作为八进制数的前缀。例如：<br>合法的八进制数：015（十进制为13）、-0101（十进制为-65）、0177777（十进制为65535）；<br>不合法的八进制数：256（无前缀0）、03A2（包含了非八进制数码）。</p><blockquote><p>注意前缀是数字0，而不是字母o。</p></blockquote><p>3) 十六进制数由数字0~9、字母A~F或a~f组成，前缀为0X或0x。例如：<br>合法的十六进制数：0X2A（十进制为42）、-0XA0（十进制为-160)、0xffff（十进制为65535）；<br>不合法的十六进制数：5A（无前缀0X）、0X3H（含有非十六进制数码）。</p><blockquote><p>在C语言中不能直接表示二进制，它没有特定的前缀</p></blockquote><h5 id="整数的后缀"><a href="#整数的后缀" class="headerlink" title="整数的后缀"></a>整数的后缀</h5><p>1) 可以用后缀L或l来表示长整型数。例如：</p><p>十进制长整型数：158L、358000L；<br>八进制长整型数：012L、077L、0200000L；<br>十六进制长整型数：0X15L (十进制为21)、0XA5L、0X10000L。</p><p>长整型数158L和基本整型数158 在数值上并无区别，但由于 158L 是长整型数，编译器将为它分配 sizeof(long) 字节的存储空间。</p><p>2) 可以用后缀U或u来表示无符号数，例如 358u、0x38Au等。</p><p>前缀、后缀可以同时使用以表示各种类型的整数。例如 0XA5Lu 表示十六进制无符号长整型数 A5，其十进制为165。</p><blockquote><p>实际开发中经常使用前缀，但较少使用后缀，因为将整数赋值给变量时就确定了它是否为 long 类型、是否为 unsigned 类型。</p></blockquote><h5 id="各种整数的输出"><a href="#各种整数的输出" class="headerlink" title="各种整数的输出"></a>各种整数的输出</h5><p>在使用 printf 输出整数时，不同的控制字符会有不同的输出格式。</p><p>1) 输出 int 使用%d，输出 short 使用 %hd，输出 long 使用 %ld。</p><p>使用 %d 输出 short，或使用 %ld 输出 int、short 时由于不会发生溢出，所以能够正确输出。而使用 %d 输出 long、或使用 %hd 输出 int、long 时可能会发生数据溢出，导致输出错误。请看下面的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">100</span>, b = <span class="number">0x10000</span>;</span><br><span class="line">    <span class="keyword">long</span> c = <span class="number">0x10</span>, d = <span class="number">0x10000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%hd, d=%hd\n"</span>, c, d);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>a=100, b=0<br>c=16, d=0</p><p>变量a、b为 unsigned short 类型，占用2个字节，能表示的最大值为 0XFFFF。a 在输出时使用 %d，能容纳的数值比 a 大，自然不会发生溢出。而 b 被赋值 0x10000，0x10000&gt;0xFFFF，在赋值时就已经发生了溢出，其值为 0，所以 %d 也输出 0。</p><p>变量 c、d 为 long 类型，占用4个字节，能表示的最大值为 0XFFFFFFFF，它们在赋值时都没有溢出。当以 %hd 输出时，会截去较高的两个字节，只输出较低两个字节中的内容。c 的值为 0x10，存储在较低的两个字节中，所以 %hd 能够正确输出。而 d 的值为 0x10000，较低的两个字节全部为0，输出时它的值也就为 0。<br>实际开发中使用 %d 和 %ld 足以，几乎不使用 %hd。<br>2) 输出无符号数使用%u。上面已经讲过，不再赘述。</p><p>3) 输出十进制使用%d，输出八进制使用%o，输出十六进制使用%x或%X。如果希望带上前缀，可以加#，例如 %#d、%#o、%#x、%#X。请看下面的例子：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>, b = <span class="number">0270</span>, c = 0X2F;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a(d)=%d, d(#d)=%#d\n"</span>, a, a);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a(o)=%o, d(#o)=%#o\n"</span>, b, b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"c(x)=%x, c(#x)=%#x, c(X)=%X, c(#X)=%#X\n"</span>, c, c, c, c);</span><br><span class="line">    <span class="keyword">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p>a(d)=100, d(#d)=100<br>a(o)=270, d(#o)=0270<br>c(x)=2f, c(#x)=0x2f, c(X)=2F, c(#X)=0X2F</p><p>需要说明的是：</p><ul><li>十进制数没有前缀，所以 %d 和 %#d 的输出结果一样。</li><li>%o、%x、%X 都是以无符号形式输出。</li></ul><h4 id="C语言中的浮点数（float-double）"><a href="#C语言中的浮点数（float-double）" class="headerlink" title="C语言中的浮点数（float,double）"></a>C语言中的浮点数（float,double）</h4><p>小数也称实数或浮点数。例如，0.0、75.0、4.023、0.27、-937.198 都是合法的小数。这是常见的小数的表现形式，称为十进制形式。</p><p>除了十进制形式，也可以采用指数形式，例如 7.25×102、0.0368×105、100.22×10-2 等。任何小数都可以用指数形式来表示<br>在C语言中小数的指数形式为：<br>aEn 或 aen<br>a 为尾数部分，是一个十进制数，n 为指数部分，是一个十进制整数，E或e是固定的字符，其值为 a×10n。例如：</p><ul><li>2.1E5 = 2.1×105，其中2.1是尾数，5是指数。</li><li>3.7E-2 = 3.7×10-2，其中3.7是尾数，-2 是指数。</li><li>0.5E7 = 0.5×107，其中0.5是尾数，7是指数。</li></ul><p>C语言中小数的数据类型为 float 或 double：float 称为单精度浮点数，double 称为双精度浮点数。不像整数，小数的长度始终是固定的，float 占用4个字节，double 占用8个字节。</p><p>10 是固定的，不需要在内存中体现出来。正负号、指数(n)、尾数(a) 是变化的，需要占用内存空间来表示。<br>float、double 在内存中的形式如下所示：</p><p>输出 float 使用 %f 控制符，输出 double 使用 %lf 控制符，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a=<span class="number">128.101</span>;</span><br><span class="line">    <span class="keyword">float</span> b=<span class="number">0.302f</span>;</span><br><span class="line">    <span class="keyword">float</span> c=<span class="number">1.23002398f</span>;</span><br><span class="line">    <span class="keyword">double</span> d=<span class="number">123</span>;</span><br><span class="line">    <span class="keyword">double</span> e = <span class="number">78.429</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%f \nb=%f \nc=%f \nd=%lf \ne=%lf\n"</span>, a, b, c, d, e);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>a=128.100998<br>b=0.302000<br>c=1.230024<br>d=123.000000<br>e=78.429000</p><p>对代码的说明：<br>1) %f 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。</p><p>2) 将整数赋值给 float 变量时会转换为小数。</p><p>3) 小数默认为 double 类型，加上后缀f才是float类型。</p><p>4) 由于内存有限，小数的精度受限，所以输出 a 时只能获得一个近似数。这点我们将在《C语言float、double的内存表示》中重点讲解。</p><h4 id="C语言中的字符（char）"><a href="#C语言中的字符（char）" class="headerlink" title="C语言中的字符（char）"></a>C语言中的字符（char）</h4><p>我们在《C语言在屏幕上显示内容》和《C语言转义字符》中提到了字符串，它是多个字符的集合，例如 “abc123”、”123\141\142\143”；当然也可以只包含一个字符，例如 “a”、”1”、”\63”。</p><p>不过为了使用方便，我们可以用 char 类型来专门表示一个字符，例如：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">char</span> b=<span class="string">'$'</span>;</span><br><span class="line"><span class="keyword">char</span> c=<span class="string">'X'</span>;</span><br><span class="line"><span class="keyword">char</span> d=<span class="string">' '</span>;  <span class="comment">// 空格也是一个字符</span></span><br><span class="line"><span class="keyword">char</span> e=<span class="string">'\63'</span>;  <span class="comment">//也可以使用转义字符的形式</span></span><br></pre></td></tr></table></figure></p><p>char 称为字符类型，只能用单引号’ ‘来包围，不能用双引号” “包围。而字符串只能用双引号” “包围，不能用单引号’ ‘包围。</p><p>输出字符使用 %c，输出字符串使用 %s。</p><p>在《C语言转义字符》中讲到的转义字符是一种特殊字符，读者可以结合本节再回忆一下。<br>字符与整数</p><p>先看下面一段代码：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    char a = <span class="string">'E'</span>;</span><br><span class="line">    char b = <span class="number">70</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">71</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="string">'H'</span>;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a=%c, a=%d\n"</span>, a, a);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"b=%c, b=%d\n"</span>, b, b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"c=%c, c=%d\n"</span>, c, c);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"d=%c, d=%d\n"</span>, d, d);</span><br><span class="line">    <span class="keyword">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>a=E, a=69<br>b=F, b=70<br>c=G, c=71<br>d=H, d=72</p><p>在ASCII码表中，E、F、G、H 的值分别是 69、70、71、72。</p><p>字符和整数没有本质的区别。可以给 char 变量一个字符，也可以给它一个整数；反过来，可以给 int 变量一个整数，也可以给它一个字符。</p><p>char 变量在内存中存储的是字符对应的 ASCII 码值。如果以 %c 输出，会根据 ASCII 码表转换成对应的字符；如果以 %d 输出，那么还是整数。</p><p>int 变量在内存中存储的是整数本身，当以 %c 输出时，也会根据 ASCII 码表转换成对应的字符。</p><p>也就是说，ASCII 码表将整数和字符关联起来了。不明白的读者请重温《ASCII编码与Unicode编码》一文，并猛击这里查看整数与字符的完整对应关系。</p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p><em>C语言中没有字符串类型，只能使用间接的方法来表示</em>。可以借助下面的形式将字符串赋值给变量：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *variableName = <span class="string">"string"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>char和*是固定的形式，variableNmae 为变量名称，”string” 是要赋值的字符串。<br>由于大家的基础还不够，这里暂时不深入探讨，大家暂时记住即可，我们会在《C语言指针》一节中详细介绍。<br>字符串使用示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"This is a string."</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char: %c\n"</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"string1: %s\n"</span>, str);</span><br><span class="line">    <span class="comment">//也可以直接输出字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"string2: %s\n"</span>, <span class="string">"This is another string."</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>char: @<br>string1: This is a string.<br>string2: This is another string.</p><h4 id="C语言标识符、关键字和注释"><a href="#C语言标识符、关键字和注释" class="headerlink" title="C语言标识符、关键字和注释"></a>C语言标识符、关键字和注释</h4><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>定义变量时，我们使用了诸如“a”“abc”“mn123”这样的名字，它们都是程序员自己起的，一般能够表达出变量的作用，这叫做标识符（Identifier）。</p><p>标识符就是程序员自己起的名字，除了变量名，后面还会讲到函数名、宏名、结构体名等。不过，名字也不能随便起，</p><blockquote><p>C语言规定，<em>标识符只能由字母(A~Z, a~z)、数字(0~9)和下划线(_)组成，并且第一个字符必须是字母或下划线</em>。</p></blockquote><p>以下标识符是合法的：<br>a, x,  x3, BOOK_1, sum5</p><p>以下标识符是非法的：<br>3s    不能以数字开头<br>s<em>T    出现非法字符</em><br>-3x    不能以减号(-)开头<br>bowy-1    出现非法字符减号(-)</p><p>在使用标识符时还必须注意以下几点：</p><ul><li>C语言虽然不限制标识符的长度，但是它受到不同编译器的限制，同时也受到具体机器的限制。例如在某个编译器中规定标识符前128位有效，当两个标识符前128位相同时，则被认为是同一个标识符。</li><li>在标识符中，大小写是有区别的，例如BOOK和book 是两个不同的标识符。</li><li>标识符虽然可由程序员随意定义，但标识符是用于标识某个量的符号，因此，命名应尽量有相应的意义，以便于阅读理解，作到“顾名思义”。</li></ul><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>关键字（Keywords）是由C语言规定的具有特定意义的字符串，通常也称为保留字，例如 int、char、long、float、unsigned 等。我们定义的标识符不能与关键字相同，否则会出现错误。</p><blockquote><p>你也可以将关键字理解为具有特殊含义的标识符，它们已经被系统使用，我们不能再使用了。<br>标准C语言中一共规定了32个关键字，大家可以参考C语言关键字及其解释[共32个]，后续我们会一一讲解</p></blockquote><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>注释（Comments）可以出现在代码中的任何位置，用来向用户提示或解释程度的意义。程序编译时，会忽略注释，不做任何处理，就好像它不存在一样。</p><p>C语言支持单行注释和多行注释：<br>单行注释以//开头，直到本行末尾（不能换行）；<br>多行注释以/<em>开头，以</em>/结尾，注释内容可以有一行或多行。</p><p>一个使用注释的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Powered by: c.biancheng.net</span></span><br><span class="line"><span class="comment">  Author: xiao p</span></span><br><span class="line"><span class="comment">  Date: 2015-6-26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* puts 会在末尾自动添加换行符 */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"http://c.biancheng.net"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"C语言中文网\n"</span>);  <span class="comment">//printf要手动添加换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br>C语言中文网</p><p>在调试程序的过程中可以将暂时不使用的语句注释掉，使编译器跳过不作处理，待调试结束后再去掉注释。</p><p>需要注意的是，多行注释 不能嵌套使用。例如下面的注释是错误的：</p><pre><code>/*C语言/*中文*/网*/</code></pre><p>而下面的注释是正确的：</p><pre><code>/*C语言中文网*/  /*c.biancheng.net*/</code></pre><h4 id="C语言加减乘除运算"><a href="#C语言加减乘除运算" class="headerlink" title="C语言加减乘除运算"></a>C语言加减乘除运算</h4><p>C语言也可以进行加减乘除运算，但是运算符号与数学中的略有不同，见下表。<br>    加法  减法  乘法  除法  求余数<br>数学  +   -   ×   ÷   无<br>C语言 +   -   *   /   %<br>加号、减号与数学中的一样，乘号、除号不同，另外C语言还多了一个求余数的运算符。</p><p>我们先来看一段代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">float</span> c=<span class="number">8.5</span>;</span><br><span class="line">    <span class="keyword">int</span> m=a+b;</span><br><span class="line">    <span class="keyword">float</span> n=b*c;</span><br><span class="line">    <span class="keyword">double</span> p=a/c;</span><br><span class="line">    <span class="keyword">int</span> q=b%a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m=%d, n=%f, p=%lf, q=%d\n"</span>, m, n, p, q);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>m=112, n=850.000000, p=1.411765, q=4</p><p>你也可以让数字直接参与运算：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">float</span> c=<span class="number">8.9</span>;</span><br><span class="line">    <span class="keyword">int</span> m=a-b;  <span class="comment">// 变量参与运算</span></span><br><span class="line">    <span class="keyword">int</span> n=a+<span class="number">239</span>;  <span class="comment">// 有变量也有数字</span></span><br><span class="line">    <span class="keyword">double</span> p=<span class="number">12.7</span>*<span class="number">34.3</span>;  <span class="comment">// 数字直接参与运算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m=%d, n=%d, p=%lf\n"</span>, m, n, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m*2=%d, 6/3=%d, m*n=%ld\n"</span>, m*<span class="number">2</span>, <span class="number">6</span>/<span class="number">3</span>, m*n);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>m=-88, n=251, p=435.610000<br>m<em>2=-176, 6/3=2, m</em>n=-22088</p><p>对于除法，需要注意的是除数不能为 0，所以诸如int a=3/0;这样的语句是错误的。</p><h5 id="加减乘除的简写"><a href="#加减乘除的简写" class="headerlink" title="加减乘除的简写"></a>加减乘除的简写</h5><p>先来看一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>, a);</span><br><span class="line">    a=a+<span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>, a);</span><br><span class="line">    a=a*b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>, a);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>a=12<br>a=20<br>a=200</p><p>第一次输出 a 原来的值；a=a+8;相当于用a+8的值替换原来 a 的值，所以第二次输出 20；第三次用a*b的值替换第二次的值，所以是 200。</p><p>在C语言中，表达式a=a#b可以简写为a#=b，#表示 +、-、*、/、% 中的任何一种运算符。</p><p>上例中a=a+8;可以简写为a+=8;，a=a<em>b;可以简写为a</em>=b;。</p><p>下面的简写形式也是正确的：<br>复制纯文本新窗口</p><p>int a = 10, b = 20;<br>a += 10;  //相当于 a = a + 10;<br>a <em>= (b-10);  //相当于 a = a </em> (b-10);<br>a -= (a+20);  //相当于 a = a - (a+20);<br>注意：a#=b 仅是一种简写，不会影响效率。</p><h4 id="C语言自增-和自减-–"><a href="#C语言自增-和自减-–" class="headerlink" title="C语言自增(++)和自减(–)"></a>C语言自增(++)和自减(–)</h4><p>一个整数自身加一可以这样写：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a+=1;</span><br></pre></td></tr></table></figure></p><p>它等价于a=a+1;。</p><p>但是在C语言中还有一种更简单的写法，就是a++;或者++a;。这种写法叫做自加或自增；意思很明确，就是自身加一。</p><p>相应的，也有a–和–a，叫做自减，表示自身减一。</p><p><strong>++和–分别称为自增和自减运算符</strong>。</p><p>自增和自减的示例：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    ++a;</span><br><span class="line">    --b;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    a++;</span><br><span class="line">    b--;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>a=10, b=20<br>a=11, b=19<br>a=12, b=18</p><p>自增自减完成后，会用新值替换旧值，并将新值保存在当前变量中。自增自减只能针对变量，不能针对数字，例如10++是错误的。</p><pre><code>值得注意的是，++ 在变量前面和后面是有区别的：++ 在前面叫做前自增（例如 ++a）。前自增先进行自增操作，再进行其他操作。++ 在后面叫做后自增（例如 a++）。后自增先进行其他操作，再进行自增操作。</code></pre><p>自减（–）也一样，有前自减和后自减之分。</p><p>请看下面的例子：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">10</span>, a1=++a;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">20</span>, b1=b++;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">30</span>, c1=--c;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">40</span>, d1=d--;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"a=%d, a1=%d\n"</span>, a, a1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"b=%d, b1=%d\n"</span>, b, b1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"c=%d, c1=%d\n"</span>, c, c1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"d=%d, d1=%d\n"</span>, d, d1);</span><br><span class="line">    <span class="keyword">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>a=11, a1=11<br>b=21, b1=20<br>c=29, c1=29<br>d=39, d1=40</p><p>a、b、c、d 的输出结果相信大家没有疑问，下面重点分析a1、b1、c1、d1：<br>1) 对于a1=++a，先执行++a，结果为11，再将11赋值给a1，所以a1的最终值为11。而a经过自增，最终的值也为11。</p><p>2) 对于b1=b++，b的值并不会立马加1，而是先把b原来的值交给b1，然后再加1。b原来的值为20，所以b1的值也就为20。而b经过自增，最终值为21。</p><p>3) 对于c1=–c，先执行–c，结果为29，再将29赋值给c1，所以c1的最终值为29。而c经过自减，最终的值也为29。</p><p>4) 对于d1=d–，d的值并不会立马减1，而是先把d原来的值交给d1，然后再减1。d原来的值为40，所以d1的值也就为40。而d经过自减，最终值为39。</p><p>可以看出：a1=++a;会先进行自增操作，再进行赋值操作；而b1=b++;会先进行赋值操作，再进行自增操作。c1=–c;和d1=d–;也是如此。<br>自增自减非常方便，后续编程中会经常用到，大家要注意区分。<br>为了强化记忆，我们再来看一个自增自减的综合示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c=a-(b--);  <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">int</span> d=(++a)-(--b);  <span class="comment">// ②</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d, d=%d\n"</span>, c, d);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>c=11, d=14</p><p>我们来分析一下：<br>1) 执行语句①时，会先进行a-b运算，结果是11，然后 b 再自减，就变成了 0，最后再将a-b的结果（也就是11）交给 c，所以 c 的值是 11。</p><p>2) 执行语句②之前，b 的值已经变成 0。对于d=(++a)-(–b)，a 会先自增，变成 13，然后 b 再自减，变成 -1，最后再进行13-(-1)，结果是14，交给 d，所以 d 最终是 14。</p><h4 id="C语言运算符的优先级和结合性"><a href="#C语言运算符的优先级和结合性" class="headerlink" title="C语言运算符的优先级和结合性"></a>C语言运算符的优先级和结合性</h4><p>先来看一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">1</span>,c=<span class="number">2</span>;</span><br><span class="line">    a=b=c;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"12+3*5=%d\n"</span>, <span class="number">12</span>+<span class="number">3</span>*<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"a=%d, c=%d\n"</span>, a, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>12+3*5=27<br>a=2, c=2</p><p>1) 对于表达式12+3<em>5，很明显先进行乘法运算，计算3</em>5，结果为15，再进行加法运算，计算12+15，结果为27。也就是说，乘法的优先级比加法高，要先计算，这与数学中的规则是一样的。</p><p>所谓优先级，就是当有多个运算符在同一个表达式中出现时，先执行哪个运算符。如果不想按照默认的规则执行，可以加( )，例如(12+3)<em>5的结果为 75，(2+5)</em>(10-4)的结果为 42。大部分情况下，它们的规则和数学中是相同的。</p><p>2) 对于语句赋值语句a=b=c;，先执行b=c，再执行a=b，而不是反过来，这说明赋值操作符=具有右结合性。</p><p>所谓结合性，就是当一个运算符多次出现时，先执行哪个运算符。先执行右边的叫右结合性，先执行左边的叫左结合性。<br>表达式（Expression）和语句（Statement）的概念在C语言中并没有明确的定义：<br>表达式可以看做一个计算的公式，往往由数据、变量、运算符等组成，例如3*4+5、a=c=d等，它的结果必定是一个值；<br>语句的范围更加广泛，不一定是计算，不一定有值，可以是某个操作、某个函数、选择结构、循环等。</p><p>值得注意的是：以分号;结束的往往称为语句，而不是表达式，例如3<em>4+5;、a=c=d;等。<br>3) 像 +、-、</em>、/ 这样的运算符，它的两边都有数据，例如 3+4、a*3 等，有两个操作数，我们称这样的运算符为双目运算符。后面还会讲解单目运算符和三目运算符。</p><p>C语言中有几十种运算符，这里不一一说明，大家可以点击《C语言运算符的优先级和结合性一览表》查看完整列表</p><p>C语言的运算符众多，具有不同的优先级和结合性，我们将它们全部列了出来，方便大家对比和记忆：<br><img src="/images/" alt=""></p><p>注：同一优先级的运算符，运算次序由结合方向所决定。</p><p>上面的表无需死记硬背，很多运算符的规则和数学中是相同的，用得多，看得多自然就记得了。如果你是在记不住，可以使用( )。</p><p>一些容易出错的优先级问题<br><img src="/images/easyErrorC.jpg" alt=""></p><p>上表中，优先级同为1 的几种运算符如果同时出现，那怎么确定表达式的优先级呢？这是很多初学者迷糊的地方。下表就整理了这些容易出错的情况：<br>这些容易出错的情况，希望读者好好在编译器上调试调试，这样印象会深一些。一定要多调试，光靠看代码，水平是很难提上来的。调试代码才是最长水平的。</p><h4 id="C语言数据类型转换"><a href="#C语言数据类型转换" class="headerlink" title="C语言数据类型转换"></a>C语言数据类型转换</h4><p>数据类型转换就是将数据（变量、表达式的结果）从一种类型转换到另一种类型。例如，为了保存小数你可以将int类型的变量转换为double类型。</p><p>数据类型转换的一般格式为：</p><pre><code>(type_name) expression</code></pre><p>type_name为要转换到的数据类型，expression为表达式。例如：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">float</span>) a<span class="comment">;  //把a转换为实型</span></span><br><span class="line">(<span class="name">int</span>)(<span class="name">x+y</span>)<span class="comment">;  //把x+y的结果转换为整型</span></span><br><span class="line">(<span class="name">float</span>) <span class="number">100</span><span class="comment">;  //将一个常量转换为实型</span></span><br></pre></td></tr></table></figure></p><p>【示例】将整数转换为浮点数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">17</span>, count = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">double</span> mean;</span><br><span class="line">   mean = (<span class="keyword">double</span>) sum / count;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of mean : %f\n"</span>, mean);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>Value of mean : 3.400000</p><p>需要注意的是，类型转换运算符( )的优先级高于/，(double) sum / count会先将 sum 转换为 double 类型，然后再进行除法运算。如果写作(double) (sum / count)，那么运行结果就是 3.000000。</p><p>这种由程序员显式进行的转换称为<strong>强制类型转换</strong>。除了强制类型转换，在不同数据类型的混合运算中编译器也会隐式地进行数据类型转换，称为<strong>自动类型转换</strong>。</p><p>自动类型转换遵循下面的规则：</p><ol><li>若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。</li><li>转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。</li><li>所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。</li><li>char型和short型参与运算时，必须先转换成int型。</li><li>在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。</li></ol><p>下图表示了类型自动转换的规则：<br><img src="/images/autoTranslate.png" alt=""></p><p>【示例】自动数据类型转换。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int main()&#123;</span><br><span class="line">    float PI=<span class="number">3</span>.<span class="number">14159</span><span class="comment">;</span></span><br><span class="line">    int <span class="built_in">s1</span>, r=<span class="number">5</span><span class="comment">;</span></span><br><span class="line">    double <span class="built_in">s2</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">s1</span> = r*r*PI<span class="comment">;</span></span><br><span class="line">    <span class="built_in">s2</span> = r*r*PI<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"s1=%d, s2=%f\n"</span>, <span class="built_in">s1</span>, <span class="built_in">s2</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>s1=78, s2=78.539753</p><p>在计算表达式<code>r*r*PI</code>时，r 和 PI 都转换成double类型，表达式的结果也为double类型。但由于 s1 为整型，所以赋值运算的结果仍为整型，舍去了小数部分。<br>注意是将小数部分直接丢掉，而不是按照四舍五入向前舍入。</p><p>无论是强制转换或是自动转换，都只是为了本次运算的需要而对变量的数据长度进行的临时性转换，而不改变数据说明时对该变量定义的类型。请看下面的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f=<span class="number">5.75</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(int)f=%d, f=%f\n"</span>,(<span class="keyword">int</span>)f, f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>(int)f=5, f=5.750000</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;GCC&quot;&gt;&lt;a href=&quot;#GCC&quot; class=&quot;headerlink&quot; title=&quot;GCC&quot;&gt;&lt;/a&gt;GCC&lt;/h4&gt;&lt;p&gt;Linux下使用最广泛的C/C++编译器是GCC，大多数的Linux发行版本都默认安装，不管是开发人员还是初学者，一般都将GCC作为Linux下首选的编译工具。&lt;/p&gt;
&lt;p&gt;保存文件后退出，打开终端并 cd 到当前目录，输入下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc test.c -o test
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以直接将C代码编译链接为可执行文件。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://yulongphp.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://yulongphp.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>30个有关Python的小技巧</title>
    <link href="http://yulongphp.github.io/2015/04/25/30%E4%B8%AA%E6%9C%89%E5%85%B3Python%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yulongphp.github.io/2015/04/25/30个有关Python的小技巧/</id>
    <published>2015-04-25T02:28:04.000Z</published>
    <updated>2018-08-22T09:43:49.627Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自 <a href="http://www.phpchina.com/forum.php" target="_blank" rel="noopener">PHPchina.com</a></p><hr><h3 id="1-拆箱"><a href="#1-拆箱" class="headerlink" title="1. 拆箱"></a>1. 拆箱</h3><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = (<span class="number">2</span> * i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, (b, c), d = [<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-拆箱变量交换"><a href="#2-拆箱变量交换" class="headerlink" title="2. 拆箱变量交换"></a>2. 拆箱变量交换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = b, a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="3-扩展拆箱（只兼容python3）"><a href="#3-扩展拆箱（只兼容python3）" class="headerlink" title="3. 扩展拆箱（只兼容python3）"></a>3. 扩展拆箱（只兼容python3）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-负数索引"><a href="#4-负数索引" class="headerlink" title="4.  负数索引"></a>4.  负数索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-1</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-3</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-切割列表"><a href="#5-切割列表" class="headerlink" title="5. 切割列表"></a>5. 切割列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">8</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="6-负数索引切割列表"><a href="#6-负数索引切割列表" class="headerlink" title="6. 负数索引切割列表"></a>6. 负数索引切割列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-4</span>:<span class="number">-2</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="7-指定步长切割列表"><a href="#7-指定步长切割列表" class="headerlink" title="7.指定步长切割列表"></a>7.指定步长切割列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">8</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="8-负数步长切割列表"><a href="#8-负数步长切割列表" class="headerlink" title="8. 负数步长切割列表"></a>8. 负数步长切割列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-2</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="9-列表切割赋值"><a href="#9-列表切割赋值" class="headerlink" title="9. 列表切割赋值"></a>9. 列表切割赋值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">3</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">-1</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="10-命名列表切割方式"><a href="#10-命名列表切割方式" class="headerlink" title="10. 命名列表切割方式"></a>10. 命名列表切割方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LASTTHREE = slice(<span class="number">-3</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LASTTHREE</span><br><span class="line">slice(<span class="number">-3</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[LASTTHREE]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="11-列表以及迭代器的压缩和解压缩"><a href="#11-列表以及迭代器的压缩和解压缩" class="headerlink" title="11. 列表以及迭代器的压缩和解压缩"></a>11. 列表以及迭代器的压缩和解压缩</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = zip(a, b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(*z)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)]</span><br></pre></td></tr></table></figure><hr><h2 id="12-列表相邻元素压缩器"><a href="#12-列表相邻元素压缩器" class="headerlink" title="12. 列表相邻元素压缩器"></a>12. 列表相邻元素压缩器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(*([iter(a)] * <span class="number">2</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: zip(*([iter(a)] * k))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(a[::<span class="number">2</span>], a[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(a[::<span class="number">3</span>], a[<span class="number">1</span>::<span class="number">3</span>], a[<span class="number">2</span>::<span class="number">3</span>])</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: zip(*(a[i::k] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">------</span><br><span class="line"><span class="comment">## 13. 在列表中用压缩器和迭代器滑动取值窗口</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">n_grams</span><span class="params">(a, n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    z = [iter(a[i:]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> zip(*z)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n_grams(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n_grams(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n_grams(a, <span class="number">4</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><hr><h2 id="14-用压缩器反转字典"><a href="#14-用压缩器反转字典" class="headerlink" title="14. 用压缩器反转字典"></a>14. 用压缩器反转字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.items()</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'d'</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(m.values(), m.keys())</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">4</span>, <span class="string">'d'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mi = dict(zip(m.values(), m.keys()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mi</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"><span class="comment">## 15. 列表展开</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain.from_iterable(a))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(a, [])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l1 <span class="keyword">in</span> a <span class="keyword">for</span> l2 <span class="keyword">in</span> l1 <span class="keyword">for</span> x <span class="keyword">in</span> l2]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flatten = <span class="keyword">lambda</span> x: [y <span class="keyword">for</span> l <span class="keyword">in</span> x <span class="keyword">for</span> y <span class="keyword">in</span> flatten(l)] <span class="keyword">if</span> type(x) <span class="keyword">is</span> list <span class="keyword">else</span> [x]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flatten(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">------</span><br><span class="line"><span class="comment">## 16. 生成器表达式</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</span><br><span class="line"><span class="number">2025</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line"><span class="number">408</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">------</span><br><span class="line"><span class="comment">## 17. 字典推导</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;x: <span class="string">'A'</span> + str(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'A0'</span>, <span class="number">1</span>: <span class="string">'A1'</span>, <span class="number">2</span>: <span class="string">'A2'</span>, <span class="number">3</span>: <span class="string">'A3'</span>, <span class="number">4</span>: <span class="string">'A4'</span>, <span class="number">5</span>: <span class="string">'A5'</span>, <span class="number">6</span>: <span class="string">'A6'</span>, <span class="number">7</span>: <span class="string">'A7'</span>, <span class="number">8</span>: <span class="string">'A8'</span>, <span class="number">9</span>: <span class="string">'A9'</span>&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">------</span><br><span class="line"><span class="comment">## 18. 用字典推导反转字典</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> m.items()&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"><span class="comment">## 19. 命名元组</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = collections.namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(x=<span class="number">1.0</span>, y=<span class="number">2.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">Point(x=<span class="number">1.0</span>, y=<span class="number">2.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">------</span><br><span class="line"><span class="comment">## 20. 继承命名元组</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(collections.namedtuple<span class="params">(<span class="string">'PointBase'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    __slots__ = ()</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> Point(x=self.x + other.x, y=self.y + other.y)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(x=<span class="number">1.0</span>, y=<span class="number">2.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Point(x=<span class="number">2.0</span>, y=<span class="number">3.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p + q</span><br><span class="line">Point(x=<span class="number">3.0</span>, y=<span class="number">5.0</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">------</span><br><span class="line"><span class="comment">## 21. 操作集合</span></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">set([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A | B</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">``` </span><br><span class="line">------</span><br><span class="line"><span class="comment">## 22. 操作多重集合</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = collections.Counter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = collections.Counter([<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A | B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A &amp; B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A + B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A - B</span><br><span class="line">Counter(&#123;<span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B - A</span><br><span class="line">Counter(&#123;<span class="number">3</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="23-统计在可迭代器中最常出现的元素"><a href="#23-统计在可迭代器中最常出现的元素" class="headerlink" title="23. 统计在可迭代器中最常出现的元素"></a>23. 统计在可迭代器中最常出现的元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = collections.Counter([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">Counter(&#123;<span class="number">3</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">5</span>: <span class="number">1</span>, <span class="number">6</span>: <span class="number">1</span>, <span class="number">7</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.most_common(<span class="number">1</span>)</span><br><span class="line">[(<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><hr><h2 id="24-两端都可操作的队列"><a href="#24-两端都可操作的队列" class="headerlink" title="24. 两端都可操作的队列"></a>24. 两端都可操作的队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q = collections.deque()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.appendleft(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.extend([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.extendleft([<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.pop()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.popleft()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.rotate(<span class="number">-3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><hr><h2 id="25-有最大长度的双端队列"><a href="#25-有最大长度的双端队列" class="headerlink" title="25. 有最大长度的双端队列"></a>25. 有最大长度的双端队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>last_three = collections.deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    last_three.append(i)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">', '</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> last_three)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span></span><br><span class="line"><span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span></span><br><span class="line"><span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure><hr><h2 id="26-可排序词典"><a href="#26-可排序词典" class="headerlink" title="26. 可排序词典"></a>26. 可排序词典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = dict((str(x), x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">', '</span>.join(m.keys())</span><br><span class="line"><span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.OrderedDict((str(x), x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">', '</span>.join(m.keys())</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.OrderedDict((str(x), x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">', '</span>.join(m.keys())</span><br><span class="line"><span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="27-默认词典"><a href="#27-默认词典" class="headerlink" title="27. 默认词典"></a>27. 默认词典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = dict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'a'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>] += <span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="keyword">lambda</span>: <span class="string">'[default value]'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</span><br><span class="line"><span class="string">'[default value]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</span><br><span class="line"><span class="string">'[default value]'</span></span><br></pre></td></tr></table></figure><hr><h2 id="28-默认字典的简单树状表达"><a href="#28-默认字典的简单树状表达" class="headerlink" title="28. 默认字典的简单树状表达"></a>28. 默认字典的简单树状表达</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = <span class="keyword">lambda</span>: collections.defaultdict(tree)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = tree()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'id'</span>] = <span class="string">'file'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'value'</span>] = <span class="string">'File'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'menuitems'</span>][<span class="string">'new'</span>][<span class="string">'value'</span>] = <span class="string">'New'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'menuitems'</span>][<span class="string">'new'</span>][<span class="string">'onclick'</span>] = <span class="string">'new();'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'menuitems'</span>][<span class="string">'open'</span>][<span class="string">'value'</span>] = <span class="string">'Open'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'menuitems'</span>][<span class="string">'open'</span>][<span class="string">'onclick'</span>] = <span class="string">'open();'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'menuitems'</span>][<span class="string">'close'</span>][<span class="string">'value'</span>] = <span class="string">'Close'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">'menu'</span>][<span class="string">'menuitems'</span>][<span class="string">'close'</span>][<span class="string">'onclick'</span>] = <span class="string">'close();'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> json.dumps(root, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"menu"</span>: &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="string">"file"</span>,</span><br><span class="line">        <span class="string">"menuitems"</span>: &#123;</span><br><span class="line">            <span class="string">"close"</span>: &#123;</span><br><span class="line">                <span class="string">"onclick"</span>: <span class="string">"close();"</span>,</span><br><span class="line">                <span class="string">"value"</span>: <span class="string">"Close"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"new"</span>: &#123;</span><br><span class="line">                <span class="string">"onclick"</span>: <span class="string">"new();"</span>,</span><br><span class="line">                <span class="string">"value"</span>: <span class="string">"New"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"open"</span>: &#123;</span><br><span class="line">                <span class="string">"onclick"</span>: <span class="string">"open();"</span>,</span><br><span class="line">                <span class="string">"value"</span>: <span class="string">"Open"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"value"</span>: <span class="string">"File"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="29-对象到唯一计数的映射"><a href="#29-对象到唯一计数的映射" class="headerlink" title="29. 对象到唯一计数的映射"></a>29. 对象到唯一计数的映射</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools, collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map = collections.defaultdict(itertools.count().next)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">'a'</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">'b'</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">'c'</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">'a'</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">'b'</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="30-最大和最小的几个列表元素"><a href="#30-最大和最小的几个列表元素" class="headerlink" title="30. 最大和最小的几个列表元素"></a>30. 最大和最小的几个列表元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> __ <span class="keyword">in</span> xrange(<span class="number">100</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nsmallest(<span class="number">5</span>, a)</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nlargest(<span class="number">5</span>, a)</span><br><span class="line">[<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="31-两个列表的笛卡尔积"><a href="#31-两个列表的笛卡尔积" class="headerlink" title="31. 两个列表的笛卡尔积"></a>31. 两个列表的笛卡尔积</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.product([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.product([<span class="number">0</span>, <span class="number">1</span>], repeat=<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> p)</span><br><span class="line">...</span><br><span class="line"><span class="number">0000</span></span><br><span class="line"><span class="number">0001</span></span><br><span class="line"><span class="number">0010</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line"><span class="number">0100</span></span><br><span class="line"><span class="number">0101</span></span><br><span class="line"><span class="number">0110</span></span><br><span class="line"><span class="number">0111</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="number">1010</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">1101</span></span><br><span class="line"><span class="number">1110</span></span><br><span class="line"><span class="number">1111</span></span><br></pre></td></tr></table></figure><hr><h2 id="32-列表组合和列表元素替代组合"><a href="#32-列表组合和列表元素替代组合" class="headerlink" title="32. 列表组合和列表元素替代组合"></a>32. 列表组合和列表元素替代组合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> itertools.combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> c)</span><br><span class="line">...</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">124</span></span><br><span class="line"><span class="number">125</span></span><br><span class="line"><span class="number">134</span></span><br><span class="line"><span class="number">135</span></span><br><span class="line"><span class="number">145</span></span><br><span class="line"><span class="number">234</span></span><br><span class="line"><span class="number">235</span></span><br><span class="line"><span class="number">245</span></span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> itertools.combinations_with_replacement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> c)</span><br><span class="line">...</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><hr><h2 id="33-列表元素排列组合"><a href="#33-列表元素排列组合" class="headerlink" title="33. 列表元素排列组合"></a>33. 列表元素排列组合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> p)</span><br><span class="line">...</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="number">1243</span></span><br><span class="line"><span class="number">1324</span></span><br><span class="line"><span class="number">1342</span></span><br><span class="line"><span class="number">1423</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">2134</span></span><br><span class="line"><span class="number">2143</span></span><br><span class="line"><span class="number">2314</span></span><br><span class="line"><span class="number">2341</span></span><br><span class="line"><span class="number">2413</span></span><br><span class="line"><span class="number">2431</span></span><br><span class="line"><span class="number">3124</span></span><br><span class="line"><span class="number">3142</span></span><br><span class="line"><span class="number">3214</span></span><br><span class="line"><span class="number">3241</span></span><br><span class="line"><span class="number">3412</span></span><br><span class="line"><span class="number">3421</span></span><br><span class="line"><span class="number">4123</span></span><br><span class="line"><span class="number">4132</span></span><br><span class="line"><span class="number">4213</span></span><br><span class="line"><span class="number">4231</span></span><br><span class="line"><span class="number">4312</span></span><br><span class="line"><span class="number">4321</span></span><br></pre></td></tr></table></figure><hr><h2 id="34-可链接迭代器"><a href="#34-可链接迭代器" class="headerlink" title="34. 可链接迭代器"></a>34. 可链接迭代器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.chain(itertools.combinations(a, <span class="number">2</span>), itertools.combinations(a, <span class="number">3</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> p</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> subset <span class="keyword">in</span> itertools.chain.from_iterable(itertools.combinations(a, n) <span class="keyword">for</span> n <span class="keyword">in</span> range(len(a) + <span class="number">1</span>))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> subset</span><br><span class="line">...</span><br><span class="line">()</span><br><span class="line">(<span class="number">1</span>,)</span><br><span class="line">(<span class="number">2</span>,)</span><br><span class="line">(<span class="number">3</span>,)</span><br><span class="line">(<span class="number">4</span>,)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="35-根据文件指定列类聚"><a href="#35-根据文件指定列类聚" class="headerlink" title="35. 根据文件指定列类聚"></a>35. 根据文件指定列类聚</h2><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools<span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'contactlenses.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> infile:<span class="meta">... </span>    data = [line.strip().split(<span class="string">','</span>) <span class="keyword">for</span> line <span class="keyword">in</span> infile]...<span class="meta">&gt;&gt;&gt; </span>data = data[<span class="number">1</span>:]<span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_data</span><span class="params">(rows)</span>:</span><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'\n'</span>.join(<span class="string">'\t'</span>.join(<span class="string">'{: &lt;16}'</span>.format(s) <span class="keyword">for</span> s <span class="keyword">in</span> row) <span class="keyword">for</span> row <span class="keyword">in</span> rows)...<span class="meta">&gt;&gt;&gt; </span>print_data(data)young               myope                   no                      reduced                 noneyoung               myope                   no                      normal                  softyoung               myope                   yes                     reduced                 noneyoung               myope                   yes                     normal                  hardyoung               hypermetrope            no                      reduced                 noneyoung               hypermetrope            no                      normal                  softyoung               hypermetrope            yes                     reduced                 noneyoung               hypermetrope            yes                     normal                  hardpre-presbyopic      myope                   no                      reduced                 nonepre-presbyopic      myope                   no                      normal                  softpre-presbyopic      myope                   yes                     reduced                 nonepre-presbyopic      myope                   yes                     normal                  hardpre-presbyopic      hypermetrope            no                      reduced                 nonepre-presbyopic      hypermetrope            no                      normal                  softpre-presbyopic      hypermetrope            yes                     reduced                 nonepre-presbyopic      hypermetrope            yes                     normal                  nonepresbyopic          myope                   no                      reduced                 nonepresbyopic          myope                   no                      normal                  nonepresbyopic          myope                   yes                     reduced                 nonepresbyopic          myope                   yes                     normal                  hardpresbyopic          hypermetrope            no                      reduced                 nonepresbyopic          hypermetrope            no                      normal                  softpresbyopic          hypermetrope            yes                     reduced                 nonepresbyopic          hypermetrope            yes                     normal                  none<span class="meta">&gt;&gt;&gt; </span>data.sort(key=<span class="keyword">lambda</span> r: r[<span class="number">-1</span>])<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> value, group <span class="keyword">in</span> itertools.groupby(data, <span class="keyword">lambda</span> r: r[<span class="number">-1</span>]):<span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'-----------'</span><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'Group: '</span> + value<span class="meta">... </span>    print_data(group)...-----------Group: hardyoung               myope                   yes                     normal                  hardyoung               hypermetrope            yes                     normal                  hardpre-presbyopic      myope                   yes                     normal                  hardpresbyopic          myope                   yes                     normal                  hard-----------Group: noneyoung               myope                   no                      reduced                 noneyoung               myope                   yes                     reduced                 noneyoung               hypermetrope            no                      reduced                 noneyoung               hypermetrope            yes                     reduced                 nonepre-presbyopic      myope                   no                      reduced                 nonepre-presbyopic      myope                   yes                     reduced                 nonepre-presbyopic      hypermetrope            no                      reduced                 nonepre-presbyopic      hypermetrope            yes                     reduced                 nonepre-presbyopic      hypermetrope            yes                     normal                  nonepresbyopic          myope                   no                      reduced                 nonepresbyopic          myope                   no                      normal                  nonepresbyopic          myope                   yes                     reduced                 nonepresbyopic          hypermetrope            no                      reduced                 nonepresbyopic          hypermetrope            yes                     reduced                 nonepresbyopic          hypermetrope            yes                     normal                  none-----------Group: softyoung               myope                   no                      normal                  softyoung               hypermetrope            no                      normal                  softpre-presbyopic      myope                   no                      normal                  softpre-presbyopic      hypermetrope            no                      normal                  softpresbyopic          hypermetrope            no                      normal                  soft</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文摘自 &lt;a href=&quot;http://www.phpchina.com/forum.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PHPchina.com&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-拆箱&quot;&gt;&lt;a href=&quot;#1-拆箱&quot; class=&quot;headerlink&quot; title=&quot;1. 拆箱&quot;&gt;&lt;/a&gt;1. 拆箱&lt;/h3&gt;
    
    </summary>
    
      <category term="python" scheme="http://yulongphp.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://yulongphp.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>debain 解决无法显示中文</title>
    <link href="http://yulongphp.github.io/2015/03/30/debain-%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87/"/>
    <id>http://yulongphp.github.io/2015/03/30/debain-解决无法显示中文/</id>
    <published>2015-03-30T07:34:11.000Z</published>
    <updated>2018-08-22T09:43:49.630Z</updated>
    
    <content type="html"><![CDATA[<p>首先先配置编码：<code>vim /etc/locale.gen</code><br>去掉前面的#</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line"></span><br><span class="line">zh_CN GB2312</span><br><span class="line"></span><br><span class="line">zh_CN.GBK GBK</span><br><span class="line"></span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br></pre></td></tr></table></figure><p>然后编辑：<code>vim /etc/default/locale</code></p><p>设置:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">LANG</span>=en_US.UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>然后安装语言包:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">apt-get install ttf-arphic-uming</span></span><br><span class="line"><span class="meta">#</span><span class="bash">apt-get install xfonts-intl-chinese</span></span><br><span class="line"><span class="meta">#</span><span class="bash">apt-get install xfonts-wqy</span></span><br></pre></td></tr></table></figure></p><p>到这里应该就可以显示中文了，没停下来查看，马不停蹄的安装输入法了<br>最后安装 <code>scim</code> 输入法相关：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">apt-get install scim</span></span><br><span class="line"><span class="meta">#</span><span class="bash">apt-get install scim-chinese</span></span><br><span class="line"><span class="meta">#</span><span class="bash">apt-get install scim-pinyin</span></span><br></pre></td></tr></table></figure></p><p>最后重启了下就ok了，输入法通过 <code>ctrl+space</code>  切换</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先先配置编码：&lt;code&gt;vim /etc/locale.gen&lt;/code&gt;&lt;br&gt;去掉前面的#&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yulongphp.github.io/categories/linux/"/>
    
    
      <category term="debian" scheme="http://yulongphp.github.io/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>python Tcl/Tk包问题</title>
    <link href="http://yulongphp.github.io/2015/03/27/python-Tcl-Tk%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yulongphp.github.io/2015/03/27/python-Tcl-Tk包问题/</id>
    <published>2015-03-27T06:47:32.000Z</published>
    <updated>2018-08-22T09:43:49.627Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学python的时候使用Tkinter包的时候出现以下问题:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">File</span> <span class="string">"/usr/local/lib/python2.7/lib-tk/Tkinter.py"</span>, <span class="built_in">line</span> <span class="number">39</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> _tkinter # If <span class="keyword">this</span> fails your Python may <span class="keyword">not</span> be configured <span class="built_in">for</span> Tk</span><br><span class="line">ImportError: No <span class="keyword">module</span> named _tkinter</span><br></pre></td></tr></table></figure></p><a id="more"></a> <p>然后就给python重新安装了一遍 结果发现：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">running</span> install</span><br><span class="line"><span class="built_in">running</span> build</span><br><span class="line"><span class="built_in">running</span> build_ext</span><br><span class="line">INFO: Can't locate Tcl/Tk libs <span class="keyword">and</span>/<span class="keyword">or</span> headers</span><br><span class="line"></span><br><span class="line">Python build finished, <span class="keyword">but</span> <span class="keyword">the</span> necessary bits <span class="keyword">to</span> build these modules were <span class="keyword">not</span> found:</span><br><span class="line">_bsddb             _curses            _curses_panel   </span><br><span class="line">_sqlite3           _tkinter           bsddb185        </span><br><span class="line">dbm                dl                 gdbm            </span><br><span class="line">imageop            sunaudiodev                        </span><br><span class="line">To find <span class="keyword">the</span> necessary bits, look <span class="keyword">in</span> setup.py <span class="keyword">in</span> detect_modules() <span class="keyword">for</span> <span class="keyword">the</span> module's <span class="built_in">name</span>.</span><br></pre></td></tr></table></figure></p><p>是少了 <code>Tcl/Tk</code>，于是就直接 <code>apt-get install tcl</code> <code>apt-get install tk</code> 安装了 <code>tcl</code> 和 <code>tk</code> 库 ，然后又执行 <code>python setup.py install</code>  安装  <code>python</code>：</p><p>结果还是不行，还是提示<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can't locate Tcl/Tk libs<span class="built_in"> and/or </span>headers</span><br></pre></td></tr></table></figure></p><p>郁闷呀;</p><p>然后就又百度了下 找到一篇博客：<a href="http://www.linuxdiyf.com/viewarticle.php?id=55587" target="_blank" rel="noopener">http://www.linuxdiyf.com/viewarticle.php?id=55587</a> 讲的比较详细：</p><p>原来 <code>setup.py</code> 安装的时候要寻找 <code>tcl.h</code> 和 <code>tk.h</code> 两个头文件，但是我用 <code>find / -name tcl.h</code> 在整个 <code>linux</code> 范围内都没有找到这个头文件。</p><p>再仔细看python.org/topics/tkinter/给出的指导：</p><p><em>You may have to install Tcl and Tk(when using RPM, install the –devel RPM as well) and /or edit the setup.py script to point to the right locations where Tcl/Tk is installed. If you install Tcl/Tk in the default locations, simply rerunning “make” should build the _tkinter extension. </em></p><p>所以我要安装 <code>tcl-devel</code>（我的系统是 <code>debian</code> 安装的是 <code>tcl-dev</code>）和 <code>tk-devel</code> （我的系统是 <code>debian</code> 安装的是 <code>tk-dev</code>）才能有头文件，安装 <code>tcl/tk</code>，只是把静态或者动态库考到 <code>lib</code> 目录下，只有 <code>tcl-devel（tc-dev）</code>，<code>tk-devel（tk-dev）</code> 才会把头文件放到 <code>/usr/include</code> 里边，而 <code>_tkinter</code> 要编译必须找到这些头文件。</p><p>然后我就执行了<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> install tcl-<span class="built_in">dev</span>    </span><br><span class="line"></span><br><span class="line">apt-<span class="built_in">get</span> install tk-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p><p>安装完这两个包后问题就解决了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在学python的时候使用Tkinter包的时候出现以下问题:&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;/usr/local/lib/python2.7/lib-tk/Tkinter.py&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;39&lt;/span&gt;, in &amp;lt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; _tkinter # If &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; fails your Python may &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; be configured &lt;span class=&quot;built_in&quot;&gt;for&lt;/span&gt; Tk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ImportError: No &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; named _tkinter&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yulongphp.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://yulongphp.github.io/tags/python/"/>
    
      <category term="tcl" scheme="http://yulongphp.github.io/tags/tcl/"/>
    
      <category term="tk" scheme="http://yulongphp.github.io/tags/tk/"/>
    
  </entry>
  
  <entry>
    <title>如何使用sublime编辑器运行python程序</title>
    <link href="http://yulongphp.github.io/2015/03/25/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8sublime%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%90%E8%A1%8Cpython%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yulongphp.github.io/2015/03/25/如何使用sublime编辑器运行python程序/</id>
    <published>2015-03-25T03:36:13.000Z</published>
    <updated>2018-08-22T09:43:49.634Z</updated>
    
    <content type="html"><![CDATA[<p>现在越发喜欢sublime编辑器了，不仅界面友好美观、文艺，可扩展性还特别强。<br>sublime本身是不具备运行python程序的能力的，需要做些设置才可以。<br>以下是安装好sublime后设置的步骤：</p><a id="more"></a><p>点击“Preference”—–》“Browse Packages”———-》“python”，编辑Python.sublime-build文件，添加python应用程序的路径，我的是安装到了c:\Python27路径中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"cmd"</span>:[<span class="string">"python.exe"</span>, <span class="string">"-u"</span>, <span class="string">"<span class="variable">$file</span>"</span>],</span><br><span class="line"> <span class="string">"path"</span>:<span class="string">"C:/Python27"</span>,</span><br><span class="line"> <span class="string">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line"> <span class="string">"selector"</span>: <span class="string">"source.python"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意:<br>:  1、代码路径和环境变量的路径中不要带中文，对中文支持还不好。<br>:  2、写完程序后，需要先保存一下，才能够运行。运行时按<code>ctrl+b</code>。</p><p>做到以上这些，就没问题了</p><p><a href="http://blog.chinaunix.net/uid-27571599-id-3481855.html" target="_blank" rel="noopener">博客原文</a>：<a href="http://blog.chinaunix.net/uid-27571599-id-3481855.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-27571599-id-3481855.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在越发喜欢sublime编辑器了，不仅界面友好美观、文艺，可扩展性还特别强。&lt;br&gt;sublime本身是不具备运行python程序的能力的，需要做些设置才可以。&lt;br&gt;以下是安装好sublime后设置的步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="sublime" scheme="http://yulongphp.github.io/categories/sublime/"/>
    
    
      <category term="python" scheme="http://yulongphp.github.io/tags/python/"/>
    
      <category term="sublime" scheme="http://yulongphp.github.io/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>Python交互模式下方向键出现乱码</title>
    <link href="http://yulongphp.github.io/2015/03/09/Python%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%96%B9%E5%90%91%E9%94%AE%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81/"/>
    <id>http://yulongphp.github.io/2015/03/09/Python交互模式下方向键出现乱码/</id>
    <published>2015-03-09T08:18:39.000Z</published>
    <updated>2018-08-22T09:43:49.630Z</updated>
    
    <content type="html"><![CDATA[<p>解决办法如下：</p><h3 id="1、安装readline模块"><a href="#1、安装readline模块" class="headerlink" title="1、安装readline模块"></a>1、安装readline模块</h3><p>readline库是bash shell用的库，包含许多功能，如命令行自动补全等。<br>ubuntu下安装的命令：<code>sudo apt-get install libreadline-dev</code></p><a id="more"></a><h3 id="2、重新安装python"><a href="#2、重新安装python" class="headerlink" title="2、重新安装python"></a>2、重新安装python</h3><p>在python的安装目录下，执行：<code>make;sudo make install</code></p><p>现在去试试看行了不，如果还是不行，就使用 <code>python</code> 自带的 <code>readline</code> 模块<br>切换到 <code>python</code> 安装目录下的 <code>Modules</code> 目录，编辑 <code>Setup</code> 文件<br>取消<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#readline</span> readline<span class="selector-class">.c</span> -lreadline -ltermcap`</span><br></pre></td></tr></table></figure></p><p>行的注释符#</p><p>再重新安装python（执行2的操作）</p><p><em>ps ： 在<code>fedora</code>下可能会出现<code>readline/readline.h:</code>没有那个文件或目录的问题(公司的是<code>ubuntu11.10</code>，我自己的机器装的是<code>fedora14</code>,出现了这个问题)<br>解决办法：</em></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> libtermcap-devel ncurses-devel libevent-devel readline-devel</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决办法如下：&lt;/p&gt;
&lt;h3 id=&quot;1、安装readline模块&quot;&gt;&lt;a href=&quot;#1、安装readline模块&quot; class=&quot;headerlink&quot; title=&quot;1、安装readline模块&quot;&gt;&lt;/a&gt;1、安装readline模块&lt;/h3&gt;&lt;p&gt;readline库是bash shell用的库，包含许多功能，如命令行自动补全等。&lt;br&gt;ubuntu下安装的命令：&lt;code&gt;sudo apt-get install libreadline-dev&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yulongphp.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://yulongphp.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>debian/ubuntu如何增加sudo权限</title>
    <link href="http://yulongphp.github.io/2015/03/09/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0sudo%E6%9D%83%E9%99%90/"/>
    <id>http://yulongphp.github.io/2015/03/09/如何增加sudo权限/</id>
    <published>2015-03-09T08:15:39.000Z</published>
    <updated>2018-08-22T09:43:49.634Z</updated>
    
    <content type="html"><![CDATA[<p>安装好Debian后还不能使用sudo<br>如果没有安装sudo，则在root用户下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install sudo</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在root设置sudoers配制文件<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +w <span class="regexp">/etc/</span>sudoers</span><br><span class="line"></span><br><span class="line">vim <span class="regexp">/etc/</span>sudoers</span><br></pre></td></tr></table></figure></p><p>添加一行<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>) <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure></p><p>其中<strong>username</strong>是你的用户名，保存<br>更改sudoers文件权限<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">0440</span> <span class="regexp">/etc/</span>sudoers</span><br></pre></td></tr></table></figure></p><p>退出root</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好Debian后还不能使用sudo&lt;br&gt;如果没有安装sudo，则在root用户下&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get install sudo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="debian" scheme="http://yulongphp.github.io/categories/debian/"/>
    
    
      <category term="debian" scheme="http://yulongphp.github.io/tags/debian/"/>
    
      <category term="ubuntu" scheme="http://yulongphp.github.io/tags/ubuntu/"/>
    
      <category term="sudo" scheme="http://yulongphp.github.io/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型list和tuple</title>
    <link href="http://yulongphp.github.io/2015/01/21/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Blist%E5%92%8Ctuple/"/>
    <id>http://yulongphp.github.io/2015/01/21/Python数据类型list和tuple/</id>
    <published>2015-01-21T03:17:10.000Z</published>
    <updated>2018-08-22T09:43:49.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>比如，列出班里所有同学的名字，就可以用一个list表示：<br><a id="more"></a></p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></code></pre><p>变量classmates就是一个list。用len()函数可以获得list元素的个数:</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></code></pre><p>用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>]</span><br><span class="line"><span class="string">'Bob'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">2</span>]</span><br><span class="line"><span class="string">'Tracy'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">3</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure></code></pre><p>当索引超出了范围时，<code>Python</code>会报一个<code>IndexError</code>错误，所以，要确保索引不要越界，记得最后一个元素的索引是<code>len(classmates) - 1</code>。</p><p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Tracy'</span></span><br></pre></td></tr></table></figure></p><p>以此类推，可以获取倒数第2个、倒数第3个：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'Bob'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-3</span>]</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-4</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure></p><p>当然，倒数第4个就越界了。</p><p><code>list</code> 是一个可变的有序表，所以，可以往list中追加元素到末尾：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></p><p>也可以把元素插入到指定的位置，比如索引号为1的位置：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></code></pre><p>要删除 <code>list</code> 末尾的元素，用 <code>pop()</code> 方法：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</span><br><span class="line"><span class="string">'Adam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></code></pre><p>要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Jack'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></code></pre><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></code></pre><p><code>list</code> 里面的元素的数据类型也可以不同，比如：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Apple'</span>, <span class="number">123</span>, <span class="keyword">True</span>]</span><br></pre></td></tr></table></figure></code></pre><p><code>list</code> 元素也可以是另一个list，比如：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></code></pre><p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = [<span class="string">'asp'</span>, <span class="string">'php'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, p, <span class="string">'scheme'</span>]</span><br></pre></td></tr></table></figure></code></pre><p>要拿到 <code>php</code> 可以写 <code>p[1]</code> 或者 <code>s[2][1]</code>，因此 <strong>s</strong> 可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</p><p>如果一个 <code>list</code> 中一个元素也没有，就是一个空的 <code>list</code> ，它的长度为0：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(L)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>另一种有序列表叫元组： <code>tuple</code>。<code>tuple</code> 和 <code>list</code> 非常类似，但是 <code>tuple</code> 一旦初始化就不能修改，比如同样是列出同学的名字：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</span><br></pre></td></tr></table></figure></code></pre><p>现在，<code>classmates</code>这个 <code>tuple</code>不能变了，它也没有 <code>append()</code>，<code>insert()</code>这样的方法。其他获取元素的方法和 <code>list</code>是一样的，你可以正常地使用 <code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。</p><p>不可变的 <code>tuple</code>有什么意义？因为 <code>tuple</code> 不可变，所以代码更安全。如果可能，能用 <code>tuple</code> 代替 <code>list</code> 就尽量用 <code>tuple</code>。</p><p><code>tuple</code> 的陷阱：当你定义一个 <code>tuple</code>时，在定义的时候， <code>tuple</code> 的元素就必须被确定下来，比如：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>如果要定义一个空的 <code>tuple</code>，可以写成()：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">()</span><br></pre></td></tr></table></figure></code></pre><p>但是，要定义一个只有1个元素的 <code>tuple</code>，如果你这么定义：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></code></pre><p>定义的不是 <code>tuple</code>，是1这个数！这是因为括号()既可以表示 <code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义，因此，<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是1。</p><p>所以，只有1个元素的 <code>tuple</code> 定义时必须加一个逗号<code>,</code>，来消除歧义：</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure></code></pre><p><code>Python</code>在显示只有1个元素的 <code>tuple</code> 时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p><p>最后来看一个<strong>“可变的”</strong> <code>tuple</code>：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = &apos;X&apos;</span><br><span class="line">&gt;&gt;&gt; t[2][1] = &apos;Y&apos;</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</span><br></pre></td></tr></table></figure></code></pre><p>这个 <code>tuple</code> 定义的时候有3个元素，分别是 <code>&#39;a&#39;</code>，<code>&#39;b&#39;</code>和一个 <code>list</code>。不是说 <code>tuple</code> 一旦定义后就不可变了吗？怎么后来又变了？</p><p>别急，我们先看看定义的时候 <code>tuple</code> 包含的3个元素：</p><p><img src="/images/tuple-0.png" alt="tuple-0"></p><p>当我们把 <code>list</code> 的元素 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code> 修改为 <code>&#39;X&#39;</code> 和 <code>&#39;Y&#39;</code> 后，<code>tuple</code>变为：<br><img src="/images/tuple-1.png" alt="tuple-1"></p><p>表面上看， <code>tuple</code>的元素确实变了，但其实变的不是 <code>tuple</code> 的元素，而是 <code>list</code> 的元素。<code>tuple</code> 一开始指向的 <code>list</code> 并没有改成别的 <code>list</code> ，所以，<code>tuple</code> 所谓的 <strong>不变</strong> 是说，<code>tuple</code> 的每个元素，指向永远不变。即指向 <code>&#39;a&#39;</code> ，就不能改成指向 <code>&#39;b&#39;</code> ，指向一个 <code>list</code> ，就不能改成指向其他对象，但指向的这个 <code>list</code> 本身是可变的！</p><p>理解了 <strong>指向不变</strong> 后，要创建一个内容也不变的 <code>tuple</code>怎么做？那就必须保证 <code>tuple</code>的每一个元素本身也不能变。</p><p><code>list</code>和 <code>tuple</code> 是 <code>Python</code>内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list&quot;&gt;&lt;/a&gt;list&lt;/h3&gt;&lt;p&gt;Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。&lt;/p&gt;
&lt;p&gt;比如，列出班里所有同学的名字，就可以用一个list表示：&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://yulongphp.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://yulongphp.github.io/tags/python/"/>
    
      <category term="list" scheme="http://yulongphp.github.io/tags/list/"/>
    
      <category term="tuple" scheme="http://yulongphp.github.io/tags/tuple/"/>
    
  </entry>
  
  <entry>
    <title>对PHP安全有帮助的一些函数</title>
    <link href="http://yulongphp.github.io/2014/12/25/%E5%AF%B9PHP%E5%AE%89%E5%85%A8%E6%9C%89%E5%B8%AE%E5%8A%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
    <id>http://yulongphp.github.io/2014/12/25/对PHP安全有帮助的一些函数/</id>
    <published>2014-12-25T04:56:19.000Z</published>
    <updated>2018-08-22T09:43:49.622Z</updated>
    
    <content type="html"><![CDATA[<p>安全一直是一个在编程语言中非常值得去关注的方面。在任何一种成熟的编程语言中都有合适的办法来保证程序的安全性，<br>在现代的 WEB开发中安全一直是一个在编程语言中非常值得去关注的方面。在任何一种成熟的编程语言中都有合适的办法<br>来保证程序的安全性，在现代的 WEB 开发中，我们常常需要去处理用户的输入。（那么这时候，问题就来了）有一句编程格言是： 千万不要相信用户输入的安全性。所以呢，今天就介绍一些在PHP 中最常用的为你的代码提供安全保护的方法。</p><a id="more"></a><p>在PHP 中有许多方便的函数可以帮助你免于类似于 SQL注入，XSS攻击。现在让我们来看一下这些能够给你的项目增加安全性的函数吧。但是，请注意，这里只是一些常用的函数的列表，也许他们并不全面，但是我相信他们都是对你的项目是非常有帮助的。</p><h2 id="mysql-real-escape-string-string-sqlQuery-："><a href="#mysql-real-escape-string-string-sqlQuery-：" class="headerlink" title="mysql_real_escape_string( string sqlQuery ) ："></a>mysql_real_escape_string( string sqlQuery ) ：</h2><p>转义 SQL 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集。一个非常有用的函数，可以有效地避免 SQL 注入。</p><p>以下字符会被转换：</p><p>\x00，\n，\r，\，’，”，\x1a</p><p>在执行sql语句之前，对要将执行的sql query 使用该函数处理，会将一些危 险扼杀在摇篮中。</p><p>但是现在一般在较为成熟的项目中，一般比较推荐使用类似 PDO 这样的数据库持久层来处理所有的数据库操作。他们代表着更为先进的数据库操作处理技术，在安全性，数据读写的速度上逗比那些古老的 mysql_* api 强大了不少。</p><h2 id="addslashes-："><a href="#addslashes-：" class="headerlink" title="addslashes() ："></a>addslashes() ：</h2><p>在将一些数据插入到数据库中时，这个函数会非常有用，它可以在单引号前加上反斜杠，使得数据在插入时不会出现错误。但是它的使用与 <code>php.ini</code>  中的一项设置有关系  —   <code>magic_quotes_gpc</code></p><p>对于<strong>PHP</strong> <code>magic_quotes_gpc=on</code>的情况，我们可以不对输入和输出数据库的字符串数据作<code>addslashes()</code>和<code>stripslashes()</code>的操作,数据也会正常显示。如果此时你对输入的数据作了<code>addslashes(</code>)处理，那么在输出的时候就必须使用<code>stripslashes()</code>去掉多余的反斜杠。</p><p>对于<strong>PHP</strong> <code>magic_quotes_gpc=off</code>的情况必须使用addslashes()对输入数据进行处理，但并不需要使用stripslashes()格式化输出，因为addslashes()并未将反斜杠一起写入数据库，只是帮助mysql完成了sql语句的执行。</p><pre><code>【stripslashes() ：删除由 addslashes() 函数添加的反斜杠。】</code></pre><h2 id="htmlentities-："><a href="#htmlentities-：" class="headerlink" title="htmlentities() ："></a>htmlentities() ：</h2><p>一个非常有用的用来处理输出的函数。它用来将一些可能导致XXS攻击的字符转化为html实体，这些字符在浏览器显示的时候是正常的，但是当你查看它的源代码时，实际上这些特殊字符必不会是他显示的那样，例如<br>输出： <code>John &amp; ‘Adams’</code><br>源码： <code>John&amp;nbsp;&amp;amp;&amp;nbsp;&#39;Adams&#39;;</code><br>输出： <code>&lt;&gt;</code><br>源码： <code>&amp;lt;&amp;gt;gt;</code><br>编码这些符号，有效地避免了XSS 攻击。</p><h2 id="htmlspecialchars-："><a href="#htmlspecialchars-：" class="headerlink" title="htmlspecialchars()："></a>htmlspecialchars()：</h2><p>和上面的函数是一样的，但是它更常用一些，因为 <code>htmlentities()</code>是将所有的有在html标准中定义了的字符转换成他们对应的html实体，这样会是你的输出缺乏易读性<a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">html 实体列表</a>。所以呢，使用<code>htmlspecialchars()</code> 只是将一些 预定义的字符(就是会导致出现问题的)转换为html实体。例如：<br><code>&amp;</code> （和号） 成为 <code>&amp;</code><br><code>”</code> （双引号） 成为 <code>”</code><br><code>‘</code> （单引号） 成为 <code>‘</code><br><code>&lt;</code> （小于） 成为 <code>&lt;</code><br><code>&gt;</code> （大于） 成为 <code>&gt;</code></p><p>所以，在一些项目中，我还是常常使用 htmlspecialchars() 来处理html 的输出的。他在安全这一方面做得更具体一些。</p><h2 id="strip-tags"><a href="#strip-tags" class="headerlink" title="strip_tags():"></a>strip_tags():</h2><p>一般在输出时使用，将HTML、XML 以及 PHP 的标签剥去。<br>函数原型： <code>strip_tags(string,allow)</code></p><ul><li>String 代表输入的字符串，</li><li>allow 代表 不删除的标签，<br>你可以通过 allow 来自定义过需要滤掉的标签</li></ul><h2 id="md5-："><a href="#md5-：" class="headerlink" title="md5() ："></a>md5() ：</h2><p>一 个将字符串转换为一个32位的哈希值的函数（不能逆向解密），任何一个字符串都能通过这个函数获得一个唯一的32位字符串。但是，现在使用这个函数时，需 要注意有一些数据库记录了大量的md5 值，通过暴力枚举的方式来破解你的密码，所以在使用的时候，你可以先将你的原字符串加一层密，然后再使用<code>md5()</code>哈希，会获得更好的效果。</p><h2 id="sha1-："><a href="#sha1-：" class="headerlink" title="sha1() ："></a>sha1() ：</h2><p>和md5() 和相似的一个函数，但是他使用不同的算法生成一个 40个字符的字符串。可以在项目中考虑使用。</p><h2 id="intval-："><a href="#intval-：" class="headerlink" title="intval() ："></a>intval() ：</h2><p>也许你认为这个函数不是一个 security function。但是它在某些情况下可以很好地保护你的code。对从用户收集到的一些数据例如 <strong>ID，password，username</strong>处理，也许可以消除一些安全隐患，毕竟这里是重灾区。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安全一直是一个在编程语言中非常值得去关注的方面。在任何一种成熟的编程语言中都有合适的办法来保证程序的安全性，&lt;br&gt;在现代的 WEB开发中安全一直是一个在编程语言中非常值得去关注的方面。在任何一种成熟的编程语言中都有合适的办法&lt;br&gt;来保证程序的安全性，在现代的 WEB 开发中，我们常常需要去处理用户的输入。（那么这时候，问题就来了）有一句编程格言是： 千万不要相信用户输入的安全性。所以呢，今天就介绍一些在PHP 中最常用的为你的代码提供安全保护的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://yulongphp.github.io/categories/php/"/>
    
    
      <category term="php" scheme="http://yulongphp.github.io/tags/php/"/>
    
      <category term="安全" scheme="http://yulongphp.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何使用service命令来管理nginx</title>
    <link href="http://yulongphp.github.io/2014/12/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8service%E5%91%BD%E4%BB%A4%E6%9D%A5%E7%AE%A1%E7%90%86nginx/"/>
    <id>http://yulongphp.github.io/2014/12/14/如何使用service命令来管理nginx/</id>
    <published>2014-12-14T14:55:19.000Z</published>
    <updated>2018-08-22T09:43:49.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何使用service命令来管理nginx？？？"><a href="#如何使用service命令来管理nginx？？？" class="headerlink" title="如何使用service命令来管理nginx？？？"></a>如何使用service命令来管理nginx？？？</h3><p>如</p><ul><li>service nginx start</li><li>service nginx restart</li><li>service nginx stop</li><li>service nginx  reload</li></ul><a id="more"></a><p>如果要是使用 service 来管理nginx 需要把nginx 安装成为一个linux下的服务</p><h4 id="1-先创建一个文件nginx，里面写入以下shell脚本-如："><a href="#1-先创建一个文件nginx，里面写入以下shell脚本-如：" class="headerlink" title="1. 先创建一个文件nginx，里面写入以下shell脚本 如："></a>1. 先创建一个文件nginx，里面写入以下shell脚本 如：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># nginx Startup script for the Nginx HTTP Server</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: - 85 15</span></span><br><span class="line"><span class="comment"># description: Nginx is a high-performance web and proxy server.</span></span><br><span class="line"><span class="comment">#              It has a lot of features, but it's not for everyone.</span></span><br><span class="line"><span class="comment"># processname: nginx</span></span><br><span class="line"><span class="comment"># pidfile: /var/run/nginx.pid</span></span><br><span class="line"><span class="comment"># config: /usr/local/nginx/conf/nginx.conf</span></span><br><span class="line"></span><br><span class="line">nginxd=/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line"></span><br><span class="line">RETVAL=0</span><br><span class="line">prog=<span class="string">"nginx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source function library.</span></span><br><span class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source networking configuration.</span></span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check that networking is up.</span></span><br><span class="line">[ <span class="variable">$&#123;NETWORKING&#125;</span> = <span class="string">"no"</span> ] &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">[ -x <span class="variable">$nginxd</span> ] || <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start nginx daemons functions.</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="variable">$nginx_pid</span> ];<span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"nginx already running...."</span></span><br><span class="line">       <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">echo</span> -n $<span class="string">"Starting <span class="variable">$prog</span>: "</span></span><br><span class="line">   daemon <span class="variable">$nginxd</span> -c <span class="variable">$&#123;nginx_config&#125;</span></span><br><span class="line">   RETVAL=$?</span><br><span class="line">   <span class="built_in">echo</span></span><br><span class="line">   [ <span class="variable">$RETVAL</span> = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   <span class="built_in">return</span> <span class="variable">$RETVAL</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stop nginx daemons functions.</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">        <span class="built_in">echo</span> -n $<span class="string">"Stopping <span class="variable">$prog</span>: "</span></span><br><span class="line">        killproc <span class="variable">$nginxd</span></span><br><span class="line">        RETVAL=$?</span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        [ <span class="variable">$RETVAL</span> = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># reload nginx service functions.</span></span><br><span class="line"><span class="function"><span class="title">reload</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Reloading <span class="variable">$prog</span>: "</span></span><br><span class="line">    <span class="comment">#kill -HUP `cat $&#123;nginx_pid&#125;`</span></span><br><span class="line">    killproc <span class="variable">$nginxd</span> -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># See how we were called.</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status <span class="variable">$prog</span></span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$prog</span> &#123;start|stop|restart|reload|status|help&#125;"</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$RETVAL</span></span><br></pre></td></tr></table></figure><h3 id="2-把这个文件复制到-etc-init-d目录下"><a href="#2-把这个文件复制到-etc-init-d目录下" class="headerlink" title="2. 把这个文件复制到/etc/init.d目录下"></a>2. 把这个文件复制到/etc/init.d目录下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./nginx /etc/init.d</span><br></pre></td></tr></table></figure><h3 id="3-修改这个文件为可执行的权限"><a href="#3-修改这个文件为可执行的权限" class="headerlink" title="3. 修改这个文件为可执行的权限"></a>3. 修改这个文件为可执行的权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/nginx</span><br></pre></td></tr></table></figure><h3 id="4-把这个可执行文件加到服务服务中去"><a href="#4-把这个可执行文件加到服务服务中去" class="headerlink" title="4. 把这个可执行文件加到服务服务中去"></a>4. 把这个可执行文件加到服务服务中去</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add nginx</span><br></pre></td></tr></table></figure><p>之后就可以使用 service 命令来管理了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何使用service命令来管理nginx？？？&quot;&gt;&lt;a href=&quot;#如何使用service命令来管理nginx？？？&quot; class=&quot;headerlink&quot; title=&quot;如何使用service命令来管理nginx？？？&quot;&gt;&lt;/a&gt;如何使用service命令来管理nginx？？？&lt;/h3&gt;&lt;p&gt;如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;service nginx start&lt;/li&gt;
&lt;li&gt;service nginx restart&lt;/li&gt;
&lt;li&gt;service nginx stop&lt;/li&gt;
&lt;li&gt;service nginx  reload&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yulongphp.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yulongphp.github.io/tags/linux/"/>
    
      <category term="service" scheme="http://yulongphp.github.io/tags/service/"/>
    
      <category term="nginx" scheme="http://yulongphp.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>vsftpd 访问 权限控制</title>
    <link href="http://yulongphp.github.io/2014/12/14/vsftpd-%E8%AE%BF%E9%97%AE-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yulongphp.github.io/2014/12/14/vsftpd-访问-权限控制/</id>
    <published>2014-12-14T12:18:49.000Z</published>
    <updated>2018-08-22T09:43:49.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vsftpd重启命令"><a href="#vsftpd重启命令" class="headerlink" title="vsftpd重启命令"></a>vsftpd重启命令</h2><pre><code>service vsftpd  start | restart | stop</code></pre><p><code>vsftpd</code> 关于权限控制，有两个文件分别设置，都会起作用</p><a id="more"></a><pre><code>/etc/vsftpd/user_list/etc/vsftpd/ftpusers</code></pre><p>如果其中系统哪个用户被禁止访问 <code>ftp</code>服务，就可以把用户的名字列在以上两个文件中，</p><p>这样的用户还有登陆linux系统的权限，如果直接删除用户也可以达到目的，但是该用户同时</p><p>也不能登陆linux系统了。</p><p>普通用户用客户端连接 <code>vsftpd</code> 时，可以越权访问一些敏感目录如何限制普通用户只能访问自己的家目录 <code>/home/username</code>，不允许访问家目录以外的目录</p><p>编辑 <code>/etc/vsftpd/vsftpd.conf</code> 文件，将一下两行代码注释去掉<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">chroot_list_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">chroot_list_file</span>=/etc/vsftpd/chroot_list</span><br></pre></td></tr></table></figure></p><p>在<code>/etc/vsftpd</code>目录下 添加 <code>chroot_list</code>  文件 ，将被限制的用户名字 添加到该文件中</p><p>重新启动 <code>vsftpd</code>服务</p><pre><code>service vsftpd restart</code></pre><p>该用户权限就被限制为只能访问自己的家目录了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vsftpd重启命令&quot;&gt;&lt;a href=&quot;#vsftpd重启命令&quot; class=&quot;headerlink&quot; title=&quot;vsftpd重启命令&quot;&gt;&lt;/a&gt;vsftpd重启命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;service vsftpd  start | restart | stop
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;vsftpd&lt;/code&gt; 关于权限控制，有两个文件分别设置，都会起作用&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yulongphp.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yulongphp.github.io/tags/linux/"/>
    
      <category term="vsftp" scheme="http://yulongphp.github.io/tags/vsftp/"/>
    
  </entry>
  
  <entry>
    <title>python 解决递归调用栈溢出</title>
    <link href="http://yulongphp.github.io/2014/12/11/python-%E8%A7%A3%E5%86%B3%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://yulongphp.github.io/2014/12/11/python-解决递归调用栈溢出/</id>
    <published>2014-12-11T07:21:31.000Z</published>
    <updated>2018-08-22T09:43:49.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>  在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><a id="more"></a><p>举个例子，我们来计算阶乘 <code>n! = 1 x 2 x 3 x ... x n</code>，用函数 <code>fact(n)</code>表示，可以看出：<br>    fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n</p><p>所以，<code>fact(n)</code> 可以表示为 <code>n x fact(n-1)</code> ，只有 <code>n=1</code> 时需要特殊处理。</p><p>于是，<code>fact(n)</code>用递归的方式写出来就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面就是一个递归函数。可以试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">100</span>)</span><br><span class="line"><span class="number">9332621544394415268169923885626670049071596826438162146859296389521759999322991560894146397615</span></span><br><span class="line"><span class="number">6518286253697920827223758251185210916864000000000000000000000000L</span></span><br></pre></td></tr></table></figure><p>如果我们计算<code>fact(5)</code>，可以根据函数定义看到计算过程如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">===&gt; fact(<span class="number">5</span>)</span><br><span class="line">===&gt; <span class="number">5</span> * fact(<span class="number">4</span>)</span><br><span class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * fact(<span class="number">3</span>))</span><br><span class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * fact(<span class="number">2</span>)))</span><br><span class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * fact(<span class="number">1</span>))))</span><br><span class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>)))</span><br><span class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * <span class="number">2</span>))</span><br><span class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * <span class="number">6</span>)</span><br><span class="line">===&gt; <span class="number">5</span> * <span class="number">24</span></span><br><span class="line">===&gt; <span class="number">120</span></span><br></pre></td></tr></table></figure><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。<br>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，<br>栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，<br>会导致栈溢出。可以试试<code>fact(1000)</code>：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">fact</span>(1000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="keyword">line</span> 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="keyword">line</span> 4, <span class="keyword">in</span> <span class="keyword">fact</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="keyword">line</span> 4, <span class="keyword">in</span> <span class="keyword">fact</span></span><br><span class="line">RuntimeError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure><p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，<br>把循环看成是一种特殊的尾递归函数也是可以的。</p><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，<br>编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><p>上面的<code>fact(n)</code> 函数由于<code>return n * fact(n - 1)</code> 引入了乘法表达式，所以就不是尾递归了。<br>要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    <span class="keyword">return</span> fact_iter(<span class="number">1</span>, <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">def fact_iter(<span class="built_in">product</span>, <span class="built_in">count</span>, <span class="built_in">max</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">product</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(<span class="built_in">product</span> * <span class="built_in">count</span>, <span class="built_in">count</span> + <span class="number">1</span>, <span class="built_in">max</span>)</span><br></pre></td></tr></table></figure><p>可以看到</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> fact_iter(<span class="built_in">product</span> * <span class="built_in">count</span>, <span class="built_in">count</span> + <span class="number">1</span>, <span class="built_in">max</span>)</span><br></pre></td></tr></table></figure><p>仅返回递归函数本身,<code>product * count</code> 和<code>count + 1</code> </p><p>在函数调用前就会被计算，不影响函数调用.<code>fact(5)</code> 对应的<code>fact_iter(1, 1, 5)</code> 的调用如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ===&gt; fact_iter(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; ===&gt; fact_iter(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; ===&gt; fact_iter(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; ===&gt; fact_iter(<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; ===&gt; fact_iter(<span class="number">24</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; ===&gt; fact_iter(<span class="number">120</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; ===&gt; <span class="number">120</span></span><br></pre></td></tr></table></figure><p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。<br>遗憾的是，大多数编程语言没有针对尾递归做优化，<code>Python</code>解释器也没有做优化，所以，<br>即使把上面的 <code>fact(n)</code> 函数改成尾递归方式，也会导致栈溢出。</p><p>有一个针对尾递归优化的 <code>decorator</code> ，可以参考源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2.4</span></span><br><span class="line"><span class="comment"># This program shows off a python decorator(</span></span><br><span class="line"><span class="comment"># which implements tail call optimization. It</span></span><br><span class="line"><span class="comment"># does this by throwing an exception if it is </span></span><br><span class="line"><span class="comment"># it's own grandparent, and catching such </span></span><br><span class="line"><span class="comment"># exceptions to recall the stack.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TailRecurseException</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, args, kwargs)</span>:</span></span><br><span class="line">    self.args = args</span><br><span class="line">    self.kwargs = kwargs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail_call_optimized</span><span class="params">(g)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  This function decorates a function with tail call</span></span><br><span class="line"><span class="string">  optimization. It does this by throwing an exception</span></span><br><span class="line"><span class="string">  if it is it's own grandparent, and catching such</span></span><br><span class="line"><span class="string">  exceptions to fake the tail call optimization.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  This function fails if the decorated</span></span><br><span class="line"><span class="string">  function recurses in a non-tail context.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    f = sys._getframe()</span><br><span class="line">    <span class="keyword">if</span> f.f_back <span class="keyword">and</span> f.f_back.f_back \</span><br><span class="line">        <span class="keyword">and</span> f.f_back.f_back.f_code == f.f_code:</span><br><span class="line">      <span class="keyword">raise</span> TailRecurseException(args, kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">          <span class="keyword">return</span> g(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> TailRecurseException, e:</span><br><span class="line">          args = e.args</span><br><span class="line">          kwargs = e.kwargs</span><br><span class="line">  func.__doc__ = g.__doc__</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n, acc=<span class="number">1</span>)</span>:</span></span><br><span class="line">  <span class="string">"calculate a factorial"</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>, n*acc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> factorial(<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># prints a big, big number,</span></span><br><span class="line"><span class="comment"># but doesn't hit the recursion limit.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(i, current = <span class="number">0</span>, next = <span class="number">1</span>)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> fib(i - <span class="number">1</span>, next, current + next)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> fib(<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># also prints a big number,</span></span><br><span class="line"><span class="comment"># but doesn't hit the recursion limit.</span></span><br></pre></td></tr></table></figure><p>现在，只需要使用这个 <code>@tail_call_optimized</code> ，就可以顺利计算出 <code>fact(1000)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1000</span>)</span><br><span class="line"><span class="number">402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递归函数&quot;&gt;&lt;a href=&quot;#递归函数&quot; class=&quot;headerlink&quot; title=&quot;递归函数&quot;&gt;&lt;/a&gt;递归函数&lt;/h2&gt;&lt;p&gt;  在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yulongphp.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://yulongphp.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yulongphp.github.io/2014/09/02/hello-world/"/>
    <id>http://yulongphp.github.io/2014/09/02/hello-world/</id>
    <published>2014-09-02T09:22:13.000Z</published>
    <updated>2018-08-22T09:43:49.625Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="MarkDown" scheme="http://yulongphp.github.io/categories/MarkDown/"/>
    
    
      <category term="MarkDown" scheme="http://yulongphp.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>vimtutor教程小结</title>
    <link href="http://yulongphp.github.io/2014/04/27/vimtutor%E6%95%99%E7%A8%8B%E5%B0%8F%E7%BB%93/"/>
    <id>http://yulongphp.github.io/2014/04/27/vimtutor教程小结/</id>
    <published>2014-04-27T06:44:02.000Z</published>
    <updated>2018-08-22T09:43:49.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一讲-小结"><a href="#第一讲-小结" class="headerlink" title="第一讲 小结"></a>第一讲 小结</h3><ol><li><p>光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。</p><p>h (左移)    j (下行)       k (上行)        l (右移)</p><a id="more"></a>     </li><li><p>欲进入 Vim 编辑器(从命令行提示符)，请输入：<code>vim 文件名</code>  <code>&lt;回车&gt;</code></p></li><li><p>欲退出 Vim 编辑器，请输入 <code>&lt;ESC&gt;</code>   <code>:q!</code>   <code>&lt;回车&gt;</code> 放弃所有改动。</p><p>或者输入 <code>&lt;ESC&gt;</code>   :wq   <code>&lt;回车&gt;</code> 保存改动。</p></li><li><p>在正常模式下删除光标所在位置的字符，请按： x</p></li><li><p>欲插入或添加文本，请输入：</p><p>i   输入欲插入文本   <code>&lt;ESC&gt;</code>        在光标前插入文本</p><p>A   输入欲添加文本   <code>&lt;ESC&gt;</code>             在一行后添加文本</p></li></ol><p><em><strong>特别提示：按下 <code>&lt;ESC&gt;</code> 键会带您回到正常模式或者撤消一个不想输入或部分完整<br>的命令。</strong></em></p><hr><h3 id="第二讲-小结"><a href="#第二讲-小结" class="headerlink" title="第二讲 小结"></a>第二讲 小结</h3><ol><li>欲从当前光标删除至下一个单词，请输入 <code>：dw</code></li><li>欲从当前光标删除至当前行末尾，请输入 <code>：d$</code></li><li><p>欲删除整行，请输入 <code>：dd</code></p></li><li><p>欲重复一个动作，请在它前面加上一个数字 <code>：2w</code></p></li><li><p>在正常模式下修改命令的格式是：</p><p><strong>operator     [number]    motion</strong></p><p>其中：</p><ul><li><p><code>operator</code> - 操作符，代表要做的事情，比如 d 代表删除</p></li><li><p><code>[number]</code> - 可以附加的数字，代表动作重复的次数</p></li><li><p><code>motion</code>   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，</p></li><li><p>$ 代表行末等等。</p></li></ul></li><li><p>欲移动光标到行首，请按数字0键：0</p></li><li><p>欲撤消以前的操作，请输入<code>：u</code> (小写的u)</p><ul><li><p>欲撤消在一行中所做的改动，请输入 <code>：U</code> (大写的U)</p></li><li><p>欲撤消以前的撤消命令，恢复以前的操作结果，请输入 <code>：CTRL-R</code></p></li></ul></li></ol><hr><h3 id="第三讲-小结"><a href="#第三讲-小结" class="headerlink" title="第三讲 小结"></a>第三讲 小结</h3><ol><li><p>要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除<br>的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置<br>于当前光标所在行的下一行。</p></li><li><p>要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字<br>符即可。</p></li><li><p>更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。<br>比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当<br>前光标到行末的内容。</p></li><li><p>更改类命令的格式是：</p><p><strong>c   [number]   motion</strong></p></li></ol><hr><h3 id="第四讲-小结"><a href="#第四讲-小结" class="headerlink" title="第四讲 小结"></a>第四讲 小结</h3><ol><li><p><code>CTRL-G</code> 用于显示当前光标所在位置和文件状态信息。</p><ul><li><p>G 用于将光标跳转至文件最后一行。</p></li><li><p>先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。</p></li><li><p>gg 用于将光标跳转至文件第一行。</p></li></ul></li><li><p>输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。</p><ul><li>输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。</li><li>完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查</li><li>找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。</li><li><code>CTRL-O</code> 带您跳转回较旧的位置，<code>CTRL-I</code>  则带您到较新的位置。</li></ul></li><li><p>如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。</p></li><li><p>在一行内替换头一个字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code></p><ul><li>在一行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:s/old/new/g</code></li><li>在两行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code></li><li>在文件内替换所有的字符串 old 为新的字符串 new，请输入  <code>:%s/old/new/g</code></li><li>进行全文替换时询问用户确认每个替换需添加 c 标志        <code>:%s/old/new/gc</code></li></ul></li></ol><hr><h3 id="第五讲-小结"><a href="#第五讲-小结" class="headerlink" title="第五讲 小结"></a>第五讲 小结</h3><ol><li><p><code>:!command</code> 用于执行一个外部命令 command。</p><p>请看一些实际例子：</p><ul><li><p>(MS-DOS)      (Unix)</p></li><li><p><code>:!dir</code>           <code>:!ls</code>           -  用于显示当前目录的内容。</p></li><li><p><code>:!del FILENAME</code>   <code>:!rm FILENAME</code>   -  用于删除名为 FILENAME 的文件。</p></li></ul></li><li><p><code>:w FILENAME</code>  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文<br>件中。</p></li><li><p><code>v motion :w FILENAME</code> 可将当前编辑文件中可视模式下选中的内容保存到文件<br>FILENAME 中。</p></li><li><p><code>:r FILENAME</code> 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置<br>后面。</p></li><li><p><code>:r !dir</code> 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。</p></li></ol><hr><h3 id="第六讲-小结"><a href="#第六讲-小结" class="headerlink" title="第六讲 小结"></a>第六讲 小结</h3><ol><li><p>输入小写的 o 可以在光标下方打开新的一行并进入插入模式。</p><p>输入大写的 O 可以在光标上方打开新的一行。</p></li><li><p>输入小写的 a 可以在光标所在位置之后插入文本。</p><p>输入大写的 A 可以在光标所在行的行末之后插入文本。</p></li><li><p>e 命令可以使光标移动到单词末尾。</p></li><li><p>操作符 y 复制文本，p 粘贴先前复制的文本。</p></li><li><p>输入大写的 R 将进入替换模式，直至按 <code>&lt;ESC&gt;</code> 键回到正常模式。</p></li><li><p>输入 <code>:set xxx</code> 可以设置 xxx 选项。一些有用的选项如下：</p><p> ‘ic’ ‘ignorecase’    查找时忽略字母大小写</p><p>‘is’ ‘incsearch’    查找短语时显示部分匹配</p><p>‘hls’ ‘hlsearch’    高亮显示所有的匹配短语</p><p>选项名可以用完整版本，也可以用缩略版本。</p></li><li><p>在选项前加上 no 可以关闭选项：  <code>:set noic</code></p></li></ol><hr><h3 id="第七讲-小结"><a href="#第七讲-小结" class="headerlink" title="第七讲 小结"></a>第七讲 小结</h3><ol><li><p>输入 <code>:help</code> 或者按 <code>&lt;F1&gt;</code> 键或 <code>&lt;Help&gt;</code> 键可以打开帮助窗口。</p></li><li><p>输入 <code>:help cmd</code> 可以找到关于 cmd 命令的帮助。</p></li><li><p>输入 <code>CTRL-W</code> <code>CTRL-W</code>  可以使您在窗口之间跳转。</p></li><li><p>输入 <code>:q</code> 以关闭帮助窗口</p></li><li><p>您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。</p></li><li><p>当输入 <code>:</code> 命令时，按 <code>CTRL-D</code> 可以查看可能的补全结果。<br>按 <code>&lt;TAB&gt;</code> 可以使用一个补全。</p></li></ol><hr><p>  vim 教程到此就结束了。本教程只是为了简明地介绍一下 Vim 编辑器，但已足以让您<br>  很容易使用这个编辑器了。毋庸质疑，vim还有很多很多的命令，本教程所介<br>  绍的距离完整的差得很远。所以您要精通的话，还望继续努力哦。下一步您可以阅读<br>  Vim 的用户手册，使用的命令是： <code>:help user-manual</code></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一讲-小结&quot;&gt;&lt;a href=&quot;#第一讲-小结&quot; class=&quot;headerlink&quot; title=&quot;第一讲 小结&quot;&gt;&lt;/a&gt;第一讲 小结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。&lt;/p&gt;
&lt;p&gt;h (左移)    j (下行)       k (上行)        l (右移)&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yulongphp.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yulongphp.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://yulongphp.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器命令介绍</title>
    <link href="http://yulongphp.github.io/2014/04/27/vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yulongphp.github.io/2014/04/27/vim编辑器命令介绍/</id>
    <published>2014-04-27T06:43:44.000Z</published>
    <updated>2018-08-22T09:43:49.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h3><p>文本编辑器，字处理器(内容为纯 <strong>ASCII</strong> )</p><p>vi：Visual Interface<br>vim： VI improved</p><p>全屏编辑器，模式化编辑器</p><p><em><strong>vim模式</strong></em>： <code>编辑模式（命令模式）</code> 、<code>输入模式</code> 、 <code>末行模式</code></p><h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><p>   编辑–&gt; 输入：</p><ul><li>i : 在当前光标所处字符的前面，转为输入模式</li><li>a : 在当前光标所处字符的后面，转为输入模式</li><li>o : 在当前光标所在行的下方，新建一行，并转为输入模式        </li><li>I : 在当前光标所在行的行首，转换为输入模式</li><li>A : 在当前光标所在行的行尾，转换为输入模式</li><li>O : 在当前光标所在行的上方，新建一行，转换为输入模式</li></ul><p>输入–&gt; 编辑：</p><ul><li>ESC</li></ul><p>编辑–&gt;末行：</p><ul><li>只有编辑模式才能转换为末行模式，输入模式不能直接转换末行模式：</li></ul><p>末行–&gt;编辑</p><ul><li>ESC，ESC</li></ul><h3 id="一、打开文件"><a href="#一、打开文件" class="headerlink" title="一、打开文件"></a>一、打开文件</h3><pre><code>vim /path/to/somefile</code></pre><ul><li>vim +#  : 打开文件并定位于第#行</li><li>vim +   : 打开文件，定位至最后一行</li><li>vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首</li></ul><p>默认处于编辑模式</p><h3 id="二、关闭文件"><a href="#二、关闭文件" class="headerlink" title="二、关闭文件"></a>二、关闭文件</h3><ol><li><p>末行模式关闭文件</p><pre><code>q   不保存退出wq  保存并退出q!  不保存退出w   保存w!  强行保存（只有管理员能操作）wq --&gt; x </code></pre></li><li><p>编辑模式下退出</p><pre><code>ZZ   保存并退出</code></pre></li></ol><h3 id="三、移动光标-（编辑模式）"><a href="#三、移动光标-（编辑模式）" class="headerlink" title="三、移动光标 （编辑模式）"></a>三、移动光标 （编辑模式）</h3><ol><li><p>逐字符移动</p><pre><code>h : 左l : 右j :    上k : 下#h : 向左移动#个字符</code></pre></li><li><p>以单词为单位移动</p><pre><code>w : 移至下一个单词的词首e : 跳至当前或下一个单词的词尾b : 跳至当前或前一个单词的词首#w </code></pre></li><li><p>行内跳转：</p><pre><code>0 : 绝对行首^ : 行首的第一个空白字符$ : 绝对行尾{ ：段落跳转(向上一个段落跳转)} ：段落跳转(向下一个段落跳转)</code></pre></li><li><p>行间跳转</p><pre><code>#G 跳转至#行G 最后一行</code></pre><p> 末行模式下，直接给出行号即可</p></li></ol><h3 id="四、-翻屏操作"><a href="#四、-翻屏操作" class="headerlink" title="四、 翻屏操作"></a>四、 翻屏操作</h3><ul><li>ctrl+f : 向下翻一屏</li><li>ctrl+b : 向上翻一屏</li><li>ctrl+d : 向下翻半屏</li><li>ctrl+u : 向上翻半屏</li></ul><h3 id="五、删除单个字符"><a href="#五、删除单个字符" class="headerlink" title="五、删除单个字符"></a>五、删除单个字符</h3><ul><li>x ： 删除光标所在处单个字符 </li><li>X :  删除光标前的字符</li><li>#x ：删除光标所在处及向后的共#个字符</li></ul><h3 id="六、删除命令：-d"><a href="#六、删除命令：-d" class="headerlink" title="六、删除命令： d"></a>六、删除命令： d</h3><ol><li><p>d命令和跳转命令组合使用</p><h4 id="d-motion"><a href="#d-motion" class="headerlink" title="d  motion"></a>d  motion</h4><pre><code>其中：    d      - 删除操作符。    motion - 操作符的操作对象(在下面列出)。一个简短的动作列表：    w - 从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符。    e - 从当前光标当前位置直到单词末尾，包括最后一个字符。    $ - 从当前光标当前位置直到当前行末。</code></pre><p> <code>#d跳转符</code> 删除跳转符指定范围的#号个</p><pre><code>#dw 删除光标所在处到下#个单词的词首之间的字符#de 删除当前光标所在位置 到  离当前光标最近的 下 第#个单词词尾 之间的字符#db </code></pre><p> <code>dd</code> ： 删除光标所在行</p><pre><code>#dd : 删除包括当前光标所在行在内的#行</code></pre><p> <code>d$</code>  (D是它的缩写): 删除当前位置到行尾的字符</p><blockquote><p>   <em><strong>上面已经提到过删除操作符和动作的组合，您可以在组合中动作之前插入一个数字以删除更多：</strong></em><br>   <strong><code>d    number(数字)    motion</code></strong></p></blockquote></li><li><p>末行模式下：</p><pre><code>startADD，endADDd    :1,8d    :.,+5d    :.,100d.   : 当前行$   : 最后一行+#  : 向下的#行</code></pre></li></ol><h3 id="七、粘贴命令"><a href="#七、粘贴命令" class="headerlink" title="七、粘贴命令"></a>七、粘贴命令</h3><ul><li><p>p：如果删除的或复制的为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面</p></li><li><p>P：如果删除的或复制的为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面</p></li></ul><h3 id="八、复制命令：-y"><a href="#八、复制命令：-y" class="headerlink" title="八、复制命令： y"></a>八、复制命令： y</h3><pre><code>用法同d命令相同</code></pre><h3 id="九、修改：先删除内容，再转换为输入模式"><a href="#九、修改：先删除内容，再转换为输入模式" class="headerlink" title="九、修改：先删除内容，再转换为输入模式"></a>九、修改：先删除内容，再转换为输入模式</h3><ul><li>c ：用法同d命令</li><li>cw：</li><li>ce：</li><li>cb：</li></ul><p><em><strong>提示：请注意 ce 命令不仅仅是删除了一个单词，它也让您进入插入模式了。</strong></em></p><h3 id="十、替换：r"><a href="#十、替换：r" class="headerlink" title="十、替换：r"></a>十、替换：r</h3><ul><li><p>r：替换单个字符</p></li><li><p>R：替换模式</p></li></ul><h3 id="十一、撤销编辑操作：u"><a href="#十一、撤销编辑操作：u" class="headerlink" title="十一、撤销编辑操作：u"></a>十一、撤销编辑操作：u</h3><ul><li><p>u：撤销前一次的编辑操作</p></li><li><p>U(大写u)： 撤消在一行中所做的改动</p></li><li><p>连续u命令可撤销此前的n此操作（vim最多可保存50次编辑操作，所以最多可撤销前50次操作）</p></li><li><p>还原最近一次撤销操作 ctrl+r</p></li></ul><h3 id="十二、重复前一次编辑操作"><a href="#十二、重复前一次编辑操作" class="headerlink" title="十二、重复前一次编辑操作"></a>十二、重复前一次编辑操作</h3><pre><code>.</code></pre><h3 id="十三、可视化模式"><a href="#十三、可视化模式" class="headerlink" title="十三、可视化模式"></a>十三、可视化模式</h3><ul><li><p>v： 按字符选取</p></li><li><p>V : 按矩形选取</p></li></ul><h3 id="十四、查找"><a href="#十四、查找" class="headerlink" title="十四、查找"></a>十四、查找</h3><ul><li><p>/pattern  从当前光标所在行向文件尾部查找符合pattern的字符</p></li><li><p>？pattern  从当前光标所在行向文件头部查找符合pattern的字符</p></li><li><p>n 跳转下一个匹配字符串</p></li><li><p>N 跳转上一个匹配字符串</p></li></ul><h3 id="十五、查找并替换"><a href="#十五、查找并替换" class="headerlink" title="十五、查找并替换"></a>十五、查找并替换</h3><ul><li><p>在末行模式下使用s命令</p></li><li><p>ADDR1，ADDR2s@PATTERN@string@gi</p><ul><li><p>如 ：1,5s/dir/DIR/g</p></li><li><p>1,$ : 表示全文</p></li><li>%  :  表示全文</li></ul></li></ul><h3 id="十六、使用vim编辑多个文件"><a href="#十六、使用vim编辑多个文件" class="headerlink" title="十六、使用vim编辑多个文件"></a>十六、使用vim编辑多个文件</h3><pre><code>vim FILE1 FILE2 FILE3    ：next 切换至下一个文件    ：prev 切换至钱一个文件    ：last 切换至最后一个文件    ：first 切换至第一个文件退出    ：qa 全部退出</code></pre><h3 id="十七、-分屏显示一个文件"><a href="#十七、-分屏显示一个文件" class="headerlink" title="十七、 分屏显示一个文件"></a>十七、 分屏显示一个文件</h3><pre><code>Ctrl+w， s ： 水平拆分窗口Ctrl+w， v ： 垂直拆分窗口在窗口件切换光标：    Ctrl+w，↑   切换到上半屏    Ctrl+w，↓   切换到下半屏    Ctrl+w，←   切换到左半屏    Ctrl+w，→   切换到右半屏：qa 关闭所有窗口</code></pre><h3 id="十八、分窗口显示多个文件"><a href="#十八、分窗口显示多个文件" class="headerlink" title="十八、分窗口显示多个文件"></a>十八、分窗口显示多个文件</h3><ul><li>vim -o ：水平分割显示</li><li>vim -O ：垂直分割显示</li></ul><h3 id="十九、将当前文件中部分内容另存为另一个文件"><a href="#十九、将当前文件中部分内容另存为另一个文件" class="headerlink" title="十九、将当前文件中部分内容另存为另一个文件"></a>十九、将当前文件中部分内容另存为另一个文件</h3><pre><code>末行模式下使用w命令    ：w    ：ADDR1，ADDR2w /path/to/somwhere</code></pre><h3 id="二十、经另外一个文件的内容填充在当前文件中"><a href="#二十、经另外一个文件的内容填充在当前文件中" class="headerlink" title="二十、经另外一个文件的内容填充在当前文件中"></a>二十、经另外一个文件的内容填充在当前文件中</h3><pre><code>：r /path/to/somewhere</code></pre><h3 id="二十一、跟shell交互"><a href="#二十一、跟shell交互" class="headerlink" title="二十一、跟shell交互"></a>二十一、跟shell交互</h3><pre><code>：！ command</code></pre><h3 id="二十二、高级话题"><a href="#二十二、高级话题" class="headerlink" title="二十二、高级话题"></a>二十二、高级话题</h3><ol><li>显示或取消行号<pre><code>：set number：set nu：set nonu</code></pre></li><li><p>显示忽略或区分字符大小写</p><pre><code>：set ignorecase：set ic：set noignorecase：set noic</code></pre></li><li><p>设置自动缩进</p><pre><code>：set sutoindent：set ai：set noai</code></pre></li><li><p>查找到的文本高高亮显示或取消</p><pre><code>：set hlsearch：set nohlsearch</code></pre></li></ol><ol start="5"><li><p>语法高亮</p><pre><code>：syntax on  开启：syntax off 关闭</code></pre><p><em><strong>这些设定只对当前vim进程生效</strong></em></p></li></ol><h3 id="二十三、配置文件"><a href="#二十三、配置文件" class="headerlink" title="二十三、配置文件"></a>二十三、配置文件</h3><ul><li>/etc/vim/vimrc ubuntu    </li><li>/etc/vimrc redhat</li><li>～/.vimrc</li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>vim 强制退出进程  </p><p>交换文件 “.initramfs.conf.swp” 已存在！<br>以只读方式打开([O]), 直接编辑((E)), 恢复((R)), 退出((Q)), 中止((A)):</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vim编辑器&quot;&gt;&lt;a href=&quot;#vim编辑器&quot; class=&quot;headerlink&quot; title=&quot;vim编辑器&quot;&gt;&lt;/a&gt;vim编辑器&lt;/h3&gt;&lt;p&gt;文本编辑器，字处理器(内容为纯 &lt;strong&gt;ASCII&lt;/strong&gt; )&lt;/p&gt;
&lt;p&gt;vi：Vis
      
    
    </summary>
    
      <category term="linux" scheme="http://yulongphp.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yulongphp.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://yulongphp.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://yulongphp.github.io/2014/03/28/%E4%BD%A0%E5%A5%BD/"/>
    <id>http://yulongphp.github.io/2014/03/28/你好/</id>
    <published>2014-03-28T07:31:19.000Z</published>
    <updated>2018-08-22T09:43:49.631Z</updated>
    
    <content type="html"><![CDATA[<p>这是<strong>新的开始</strong>，我用hexo创建了第一篇文章。</p><p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p><p>感觉非常好。</p><p><strong>引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Swig语法</span><br><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br><span class="line"></span><br><span class="line"># Markdown语法</span><br><span class="line">&gt; Every interaction is both precious and an opportunity to delight.</span><br></pre></td></tr></table></figure><p><strong>代码块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Swig语法</span><br><span class="line">&#123;% codeblock .compact http://underscorejs.org/#compact Underscore.js %&#125;</span><br><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line"></span><br><span class="line"># Markdown语法</span><br><span class="line">```&#123;bash&#125;</span><br><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br><span class="line">```</span><br></pre></td></tr></table></figure></p><p><strong>连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 粉丝日志 http://blog.fens.me true 粉丝日志 %&#125;</span><br><span class="line"></span><br><span class="line"># Markdown语法</span><br><span class="line">[粉丝日志](http://blog.fens.me)</span><br></pre></td></tr></table></figure><p><strong>图片，对于本地图片，需要在source目录下面新建一个目录images，然后把图片放到目录中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Swig语法</span><br><span class="line">&#123;% img /images/fens.me.png 400 600 这是一张图片 %&#125;</span><br><span class="line"></span><br><span class="line"># Markdown语法</span><br><span class="line">![这是一张图片](/images/fens.me.png)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是&lt;strong&gt;新的开始&lt;/strong&gt;，我用hexo创建了第一篇文章。&lt;/p&gt;
&lt;p&gt;通过下面的命令，就可以创建新文章&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="日志" scheme="http://yulongphp.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="开始" scheme="http://yulongphp.github.io/tags/%E5%BC%80%E5%A7%8B/"/>
    
      <category term="我" scheme="http://yulongphp.github.io/tags/%E6%88%91/"/>
    
      <category term="日记" scheme="http://yulongphp.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
